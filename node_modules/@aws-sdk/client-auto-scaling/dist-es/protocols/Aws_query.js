import { HttpRequest as __HttpRequest } from "@aws-sdk/protocol-http";
import { decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, getValueFromTextNode as __getValueFromTextNode, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeFloat as __serializeFloat, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, withBaseException, } from "@aws-sdk/smithy-client";
import { XMLParser } from "fast-xml-parser";
import { AutoScalingServiceException as __BaseException } from "../models/AutoScalingServiceException";
import { ActiveInstanceRefreshNotFoundFault, AlreadyExistsFault, InstanceRefreshInProgressFault, InvalidNextToken, IrreversibleInstanceRefreshFault, LimitExceededFault, ResourceContentionFault, ResourceInUseFault, ScalingActivityInProgressFault, ServiceLinkedRoleFailure, } from "../models/models_0";
export const se_AttachInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachInstancesQuery(input, context),
        Action: "AttachInstances",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachLoadBalancersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachLoadBalancersType(input, context),
        Action: "AttachLoadBalancers",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachLoadBalancerTargetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachLoadBalancerTargetGroupsType(input, context),
        Action: "AttachLoadBalancerTargetGroups",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachTrafficSourcesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachTrafficSourcesType(input, context),
        Action: "AttachTrafficSources",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BatchDeleteScheduledActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BatchDeleteScheduledActionType(input, context),
        Action: "BatchDeleteScheduledAction",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BatchPutScheduledUpdateGroupActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BatchPutScheduledUpdateGroupActionType(input, context),
        Action: "BatchPutScheduledUpdateGroupAction",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelInstanceRefreshCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelInstanceRefreshType(input, context),
        Action: "CancelInstanceRefresh",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CompleteLifecycleActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CompleteLifecycleActionType(input, context),
        Action: "CompleteLifecycleAction",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAutoScalingGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAutoScalingGroupType(input, context),
        Action: "CreateAutoScalingGroup",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLaunchConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLaunchConfigurationType(input, context),
        Action: "CreateLaunchConfiguration",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateOrUpdateTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateOrUpdateTagsType(input, context),
        Action: "CreateOrUpdateTags",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAutoScalingGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAutoScalingGroupType(input, context),
        Action: "DeleteAutoScalingGroup",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLaunchConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_LaunchConfigurationNameType(input, context),
        Action: "DeleteLaunchConfiguration",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLifecycleHookCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLifecycleHookType(input, context),
        Action: "DeleteLifecycleHook",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteNotificationConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteNotificationConfigurationType(input, context),
        Action: "DeleteNotificationConfiguration",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeletePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePolicyType(input, context),
        Action: "DeletePolicy",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteScheduledActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteScheduledActionType(input, context),
        Action: "DeleteScheduledAction",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTagsType(input, context),
        Action: "DeleteTags",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteWarmPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteWarmPoolType(input, context),
        Action: "DeleteWarmPool",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAccountLimitsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "DescribeAccountLimits",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAdjustmentTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "DescribeAdjustmentTypes",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAutoScalingGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AutoScalingGroupNamesType(input, context),
        Action: "DescribeAutoScalingGroups",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAutoScalingInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAutoScalingInstancesType(input, context),
        Action: "DescribeAutoScalingInstances",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAutoScalingNotificationTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "DescribeAutoScalingNotificationTypes",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceRefreshesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInstanceRefreshesType(input, context),
        Action: "DescribeInstanceRefreshes",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLaunchConfigurationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_LaunchConfigurationNamesType(input, context),
        Action: "DescribeLaunchConfigurations",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLifecycleHooksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLifecycleHooksType(input, context),
        Action: "DescribeLifecycleHooks",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLifecycleHookTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "DescribeLifecycleHookTypes",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancersRequest(input, context),
        Action: "DescribeLoadBalancers",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancerTargetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancerTargetGroupsRequest(input, context),
        Action: "DescribeLoadBalancerTargetGroups",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMetricCollectionTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "DescribeMetricCollectionTypes",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNotificationConfigurationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNotificationConfigurationsType(input, context),
        Action: "DescribeNotificationConfigurations",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribePoliciesType(input, context),
        Action: "DescribePolicies",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScalingActivitiesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeScalingActivitiesType(input, context),
        Action: "DescribeScalingActivities",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScalingProcessTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "DescribeScalingProcessTypes",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScheduledActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeScheduledActionsType(input, context),
        Action: "DescribeScheduledActions",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTagsType(input, context),
        Action: "DescribeTags",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTerminationPolicyTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "DescribeTerminationPolicyTypes",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTrafficSourcesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTrafficSourcesRequest(input, context),
        Action: "DescribeTrafficSources",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeWarmPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeWarmPoolType(input, context),
        Action: "DescribeWarmPool",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachInstancesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachInstancesQuery(input, context),
        Action: "DetachInstances",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachLoadBalancersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachLoadBalancersType(input, context),
        Action: "DetachLoadBalancers",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachLoadBalancerTargetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachLoadBalancerTargetGroupsType(input, context),
        Action: "DetachLoadBalancerTargetGroups",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachTrafficSourcesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachTrafficSourcesType(input, context),
        Action: "DetachTrafficSources",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableMetricsCollectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableMetricsCollectionQuery(input, context),
        Action: "DisableMetricsCollection",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableMetricsCollectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableMetricsCollectionQuery(input, context),
        Action: "EnableMetricsCollection",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnterStandbyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnterStandbyQuery(input, context),
        Action: "EnterStandby",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExecutePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExecutePolicyType(input, context),
        Action: "ExecutePolicy",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ExitStandbyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ExitStandbyQuery(input, context),
        Action: "ExitStandby",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetPredictiveScalingForecastCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetPredictiveScalingForecastType(input, context),
        Action: "GetPredictiveScalingForecast",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutLifecycleHookCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutLifecycleHookType(input, context),
        Action: "PutLifecycleHook",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutNotificationConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutNotificationConfigurationType(input, context),
        Action: "PutNotificationConfiguration",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutScalingPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutScalingPolicyType(input, context),
        Action: "PutScalingPolicy",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutScheduledUpdateGroupActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutScheduledUpdateGroupActionType(input, context),
        Action: "PutScheduledUpdateGroupAction",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutWarmPoolCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutWarmPoolType(input, context),
        Action: "PutWarmPool",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RecordLifecycleActionHeartbeatCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RecordLifecycleActionHeartbeatType(input, context),
        Action: "RecordLifecycleActionHeartbeat",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResumeProcessesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ScalingProcessQuery(input, context),
        Action: "ResumeProcesses",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RollbackInstanceRefreshCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RollbackInstanceRefreshType(input, context),
        Action: "RollbackInstanceRefresh",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetDesiredCapacityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetDesiredCapacityType(input, context),
        Action: "SetDesiredCapacity",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetInstanceHealthCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetInstanceHealthQuery(input, context),
        Action: "SetInstanceHealth",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetInstanceProtectionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetInstanceProtectionQuery(input, context),
        Action: "SetInstanceProtection",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartInstanceRefreshCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartInstanceRefreshType(input, context),
        Action: "StartInstanceRefresh",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SuspendProcessesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ScalingProcessQuery(input, context),
        Action: "SuspendProcesses",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TerminateInstanceInAutoScalingGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TerminateInstanceInAutoScalingGroupType(input, context),
        Action: "TerminateInstanceInAutoScalingGroup",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAutoScalingGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAutoScalingGroupType(input, context),
        Action: "UpdateAutoScalingGroup",
        Version: "2011-01-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AttachInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachInstancesCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_AttachInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_AttachLoadBalancersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachLoadBalancersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachLoadBalancersResultType(data.AttachLoadBalancersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_AttachLoadBalancersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_AttachLoadBalancerTargetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachLoadBalancerTargetGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachLoadBalancerTargetGroupsResultType(data.AttachLoadBalancerTargetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_AttachLoadBalancerTargetGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_AttachTrafficSourcesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachTrafficSourcesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachTrafficSourcesResultType(data.AttachTrafficSourcesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_AttachTrafficSourcesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_BatchDeleteScheduledActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchDeleteScheduledActionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchDeleteScheduledActionAnswer(data.BatchDeleteScheduledActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_BatchDeleteScheduledActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_BatchPutScheduledUpdateGroupActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_BatchPutScheduledUpdateGroupActionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchPutScheduledUpdateGroupActionAnswer(data.BatchPutScheduledUpdateGroupActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_BatchPutScheduledUpdateGroupActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExists":
        case "com.amazonaws.autoscaling#AlreadyExistsFault":
            throw await de_AlreadyExistsFaultRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CancelInstanceRefreshCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CancelInstanceRefreshCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelInstanceRefreshAnswer(data.CancelInstanceRefreshResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CancelInstanceRefreshCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ActiveInstanceRefreshNotFound":
        case "com.amazonaws.autoscaling#ActiveInstanceRefreshNotFoundFault":
            throw await de_ActiveInstanceRefreshNotFoundFaultRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CompleteLifecycleActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CompleteLifecycleActionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CompleteLifecycleActionAnswer(data.CompleteLifecycleActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CompleteLifecycleActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateAutoScalingGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAutoScalingGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_CreateAutoScalingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExists":
        case "com.amazonaws.autoscaling#AlreadyExistsFault":
            throw await de_AlreadyExistsFaultRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateLaunchConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateLaunchConfigurationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_CreateLaunchConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExists":
        case "com.amazonaws.autoscaling#AlreadyExistsFault":
            throw await de_AlreadyExistsFaultRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateOrUpdateTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateOrUpdateTagsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_CreateOrUpdateTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExists":
        case "com.amazonaws.autoscaling#AlreadyExistsFault":
            throw await de_AlreadyExistsFaultRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.autoscaling#ResourceInUseFault":
            throw await de_ResourceInUseFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteAutoScalingGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAutoScalingGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteAutoScalingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.autoscaling#ResourceInUseFault":
            throw await de_ResourceInUseFaultRes(parsedOutput, context);
        case "ScalingActivityInProgress":
        case "com.amazonaws.autoscaling#ScalingActivityInProgressFault":
            throw await de_ScalingActivityInProgressFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteLaunchConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteLaunchConfigurationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteLaunchConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.autoscaling#ResourceInUseFault":
            throw await de_ResourceInUseFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteLifecycleHookCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteLifecycleHookCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLifecycleHookAnswer(data.DeleteLifecycleHookResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteLifecycleHookCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteNotificationConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteNotificationConfigurationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteNotificationConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeletePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeletePolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeletePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteScheduledActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteScheduledActionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteScheduledActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteTagsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.autoscaling#ResourceInUseFault":
            throw await de_ResourceInUseFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteWarmPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteWarmPoolCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteWarmPoolAnswer(data.DeleteWarmPoolResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteWarmPoolCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.autoscaling#ResourceInUseFault":
            throw await de_ResourceInUseFaultRes(parsedOutput, context);
        case "ScalingActivityInProgress":
        case "com.amazonaws.autoscaling#ScalingActivityInProgressFault":
            throw await de_ScalingActivityInProgressFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeAccountLimitsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAccountLimitsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAccountLimitsAnswer(data.DescribeAccountLimitsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAccountLimitsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeAdjustmentTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAdjustmentTypesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAdjustmentTypesAnswer(data.DescribeAdjustmentTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAdjustmentTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeAutoScalingGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAutoScalingGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AutoScalingGroupsType(data.DescribeAutoScalingGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAutoScalingGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeAutoScalingInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAutoScalingInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AutoScalingInstancesType(data.DescribeAutoScalingInstancesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAutoScalingInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeAutoScalingNotificationTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAutoScalingNotificationTypesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAutoScalingNotificationTypesAnswer(data.DescribeAutoScalingNotificationTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAutoScalingNotificationTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeInstanceRefreshesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeInstanceRefreshesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceRefreshesAnswer(data.DescribeInstanceRefreshesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeInstanceRefreshesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeLaunchConfigurationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeLaunchConfigurationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_LaunchConfigurationsType(data.DescribeLaunchConfigurationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeLaunchConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeLifecycleHooksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeLifecycleHooksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLifecycleHooksAnswer(data.DescribeLifecycleHooksResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeLifecycleHooksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeLifecycleHookTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeLifecycleHookTypesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLifecycleHookTypesAnswer(data.DescribeLifecycleHookTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeLifecycleHookTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeLoadBalancersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeLoadBalancersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancersResponse(data.DescribeLoadBalancersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeLoadBalancersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeLoadBalancerTargetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeLoadBalancerTargetGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancerTargetGroupsResponse(data.DescribeLoadBalancerTargetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeLoadBalancerTargetGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeMetricCollectionTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMetricCollectionTypesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMetricCollectionTypesAnswer(data.DescribeMetricCollectionTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeMetricCollectionTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeNotificationConfigurationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeNotificationConfigurationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeNotificationConfigurationsAnswer(data.DescribeNotificationConfigurationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeNotificationConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribePoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PoliciesType(data.DescribePoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeScalingActivitiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeScalingActivitiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ActivitiesType(data.DescribeScalingActivitiesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeScalingActivitiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeScalingProcessTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeScalingProcessTypesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ProcessesType(data.DescribeScalingProcessTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeScalingProcessTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeScheduledActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeScheduledActionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ScheduledActionsType(data.DescribeScheduledActionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeScheduledActionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TagsType(data.DescribeTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeTerminationPolicyTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTerminationPolicyTypesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTerminationPolicyTypesAnswer(data.DescribeTerminationPolicyTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeTerminationPolicyTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeTrafficSourcesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTrafficSourcesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTrafficSourcesResponse(data.DescribeTrafficSourcesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeTrafficSourcesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeWarmPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeWarmPoolCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeWarmPoolAnswer(data.DescribeWarmPoolResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeWarmPoolCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.autoscaling#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DetachInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachInstancesAnswer(data.DetachInstancesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DetachInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DetachLoadBalancersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachLoadBalancersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachLoadBalancersResultType(data.DetachLoadBalancersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DetachLoadBalancersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DetachLoadBalancerTargetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachLoadBalancerTargetGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachLoadBalancerTargetGroupsResultType(data.DetachLoadBalancerTargetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DetachLoadBalancerTargetGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DetachTrafficSourcesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachTrafficSourcesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachTrafficSourcesResultType(data.DetachTrafficSourcesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DetachTrafficSourcesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DisableMetricsCollectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisableMetricsCollectionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DisableMetricsCollectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_EnableMetricsCollectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableMetricsCollectionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_EnableMetricsCollectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_EnterStandbyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnterStandbyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnterStandbyAnswer(data.EnterStandbyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_EnterStandbyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ExecutePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ExecutePolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_ExecutePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ScalingActivityInProgress":
        case "com.amazonaws.autoscaling#ScalingActivityInProgressFault":
            throw await de_ScalingActivityInProgressFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ExitStandbyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ExitStandbyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ExitStandbyAnswer(data.ExitStandbyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ExitStandbyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetPredictiveScalingForecastCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPredictiveScalingForecastCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPredictiveScalingForecastAnswer(data.GetPredictiveScalingForecastResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetPredictiveScalingForecastCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutLifecycleHookCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutLifecycleHookCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutLifecycleHookAnswer(data.PutLifecycleHookResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutLifecycleHookCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutNotificationConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutNotificationConfigurationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutNotificationConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutScalingPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutScalingPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PolicyARNType(data.PutScalingPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutScalingPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutScheduledUpdateGroupActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutScheduledUpdateGroupActionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutScheduledUpdateGroupActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExists":
        case "com.amazonaws.autoscaling#AlreadyExistsFault":
            throw await de_AlreadyExistsFaultRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutWarmPoolCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutWarmPoolCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutWarmPoolAnswer(data.PutWarmPoolResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutWarmPoolCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_RecordLifecycleActionHeartbeatCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RecordLifecycleActionHeartbeatCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RecordLifecycleActionHeartbeatAnswer(data.RecordLifecycleActionHeartbeatResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_RecordLifecycleActionHeartbeatCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ResumeProcessesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ResumeProcessesCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_ResumeProcessesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.autoscaling#ResourceInUseFault":
            throw await de_ResourceInUseFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_RollbackInstanceRefreshCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RollbackInstanceRefreshCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RollbackInstanceRefreshAnswer(data.RollbackInstanceRefreshResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_RollbackInstanceRefreshCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ActiveInstanceRefreshNotFound":
        case "com.amazonaws.autoscaling#ActiveInstanceRefreshNotFoundFault":
            throw await de_ActiveInstanceRefreshNotFoundFaultRes(parsedOutput, context);
        case "IrreversibleInstanceRefresh":
        case "com.amazonaws.autoscaling#IrreversibleInstanceRefreshFault":
            throw await de_IrreversibleInstanceRefreshFaultRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_SetDesiredCapacityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetDesiredCapacityCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_SetDesiredCapacityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ScalingActivityInProgress":
        case "com.amazonaws.autoscaling#ScalingActivityInProgressFault":
            throw await de_ScalingActivityInProgressFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_SetInstanceHealthCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetInstanceHealthCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_SetInstanceHealthCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_SetInstanceProtectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetInstanceProtectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetInstanceProtectionAnswer(data.SetInstanceProtectionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_SetInstanceProtectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_StartInstanceRefreshCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartInstanceRefreshCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartInstanceRefreshAnswer(data.StartInstanceRefreshResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_StartInstanceRefreshCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InstanceRefreshInProgress":
        case "com.amazonaws.autoscaling#InstanceRefreshInProgressFault":
            throw await de_InstanceRefreshInProgressFaultRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.autoscaling#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_SuspendProcessesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SuspendProcessesCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_SuspendProcessesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.autoscaling#ResourceInUseFault":
            throw await de_ResourceInUseFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TerminateInstanceInAutoScalingGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TerminateInstanceInAutoScalingGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ActivityType(data.TerminateInstanceInAutoScalingGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_TerminateInstanceInAutoScalingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ScalingActivityInProgress":
        case "com.amazonaws.autoscaling#ScalingActivityInProgressFault":
            throw await de_ScalingActivityInProgressFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateAutoScalingGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAutoScalingGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateAutoScalingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceContention":
        case "com.amazonaws.autoscaling#ResourceContentionFault":
            throw await de_ResourceContentionFaultRes(parsedOutput, context);
        case "ScalingActivityInProgress":
        case "com.amazonaws.autoscaling#ScalingActivityInProgressFault":
            throw await de_ScalingActivityInProgressFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleFailure":
        case "com.amazonaws.autoscaling#ServiceLinkedRoleFailure":
            throw await de_ServiceLinkedRoleFailureRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ActiveInstanceRefreshNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ActiveInstanceRefreshNotFoundFault(body.Error, context);
    const exception = new ActiveInstanceRefreshNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AlreadyExistsFault(body.Error, context);
    const exception = new AlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InstanceRefreshInProgressFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InstanceRefreshInProgressFault(body.Error, context);
    const exception = new InstanceRefreshInProgressFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNextTokenRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidNextToken(body.Error, context);
    const exception = new InvalidNextToken({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IrreversibleInstanceRefreshFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IrreversibleInstanceRefreshFault(body.Error, context);
    const exception = new IrreversibleInstanceRefreshFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededFault(body.Error, context);
    const exception = new LimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceContentionFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceContentionFault(body.Error, context);
    const exception = new ResourceContentionFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceInUseFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceInUseFault(body.Error, context);
    const exception = new ResourceInUseFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ScalingActivityInProgressFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ScalingActivityInProgressFault(body.Error, context);
    const exception = new ScalingActivityInProgressFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceLinkedRoleFailureRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceLinkedRoleFailure(body.Error, context);
    const exception = new ServiceLinkedRoleFailure({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AcceleratorCountRequest = (input, context) => {
    const entries = {};
    if (input.Min != null) {
        entries["Min"] = input.Min;
    }
    if (input.Max != null) {
        entries["Max"] = input.Max;
    }
    return entries;
};
const se_AcceleratorManufacturers = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AcceleratorNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AcceleratorTotalMemoryMiBRequest = (input, context) => {
    const entries = {};
    if (input.Min != null) {
        entries["Min"] = input.Min;
    }
    if (input.Max != null) {
        entries["Max"] = input.Max;
    }
    return entries;
};
const se_AcceleratorTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ActivityIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AllowedInstanceTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AttachInstancesQuery = (input, context) => {
    const entries = {};
    if (input.InstanceIds != null) {
        const memberEntries = se_InstanceIds(input.InstanceIds, context);
        if (input.InstanceIds?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    return entries;
};
const se_AttachLoadBalancersType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.LoadBalancerNames != null) {
        const memberEntries = se_LoadBalancerNames(input.LoadBalancerNames, context);
        if (input.LoadBalancerNames?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AttachLoadBalancerTargetGroupsType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.TargetGroupARNs != null) {
        const memberEntries = se_TargetGroupARNs(input.TargetGroupARNs, context);
        if (input.TargetGroupARNs?.length === 0) {
            entries.TargetGroupARNs = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupARNs.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AttachTrafficSourcesType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.TrafficSources != null) {
        const memberEntries = se_TrafficSources(input.TrafficSources, context);
        if (input.TrafficSources?.length === 0) {
            entries.TrafficSources = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficSources.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AutoScalingGroupNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AutoScalingGroupNamesType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupNames != null) {
        const memberEntries = se_AutoScalingGroupNames(input.AutoScalingGroupNames, context);
        if (input.AutoScalingGroupNames?.length === 0) {
            entries.AutoScalingGroupNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AutoScalingGroupNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    if (input.Filters != null) {
        const memberEntries = se_Filters(input.Filters, context);
        if (input.Filters?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AutoScalingNotificationTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AvailabilityZones = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_BaselineEbsBandwidthMbpsRequest = (input, context) => {
    const entries = {};
    if (input.Min != null) {
        entries["Min"] = input.Min;
    }
    if (input.Max != null) {
        entries["Max"] = input.Max;
    }
    return entries;
};
const se_BatchDeleteScheduledActionType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ScheduledActionNames != null) {
        const memberEntries = se_ScheduledActionNames(input.ScheduledActionNames, context);
        if (input.ScheduledActionNames?.length === 0) {
            entries.ScheduledActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScheduledActionNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_BatchPutScheduledUpdateGroupActionType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ScheduledUpdateGroupActions != null) {
        const memberEntries = se_ScheduledUpdateGroupActionRequests(input.ScheduledUpdateGroupActions, context);
        if (input.ScheduledUpdateGroupActions?.length === 0) {
            entries.ScheduledUpdateGroupActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScheduledUpdateGroupActions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_BlockDeviceMapping = (input, context) => {
    const entries = {};
    if (input.VirtualName != null) {
        entries["VirtualName"] = input.VirtualName;
    }
    if (input.DeviceName != null) {
        entries["DeviceName"] = input.DeviceName;
    }
    if (input.Ebs != null) {
        const memberEntries = se_Ebs(input.Ebs, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Ebs.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NoDevice != null) {
        entries["NoDevice"] = input.NoDevice;
    }
    return entries;
};
const se_BlockDeviceMappings = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_BlockDeviceMapping(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_CancelInstanceRefreshType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    return entries;
};
const se_CheckpointPercentages = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ClassicLinkVPCSecurityGroups = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CompleteLifecycleActionType = (input, context) => {
    const entries = {};
    if (input.LifecycleHookName != null) {
        entries["LifecycleHookName"] = input.LifecycleHookName;
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.LifecycleActionToken != null) {
        entries["LifecycleActionToken"] = input.LifecycleActionToken;
    }
    if (input.LifecycleActionResult != null) {
        entries["LifecycleActionResult"] = input.LifecycleActionResult;
    }
    if (input.InstanceId != null) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const se_CpuManufacturers = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CreateAutoScalingGroupType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.LaunchConfigurationName != null) {
        entries["LaunchConfigurationName"] = input.LaunchConfigurationName;
    }
    if (input.LaunchTemplate != null) {
        const memberEntries = se_LaunchTemplateSpecification(input.LaunchTemplate, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MixedInstancesPolicy != null) {
        const memberEntries = se_MixedInstancesPolicy(input.MixedInstancesPolicy, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MixedInstancesPolicy.${key}`;
            entries[loc] = value;
        });
    }
    if (input.InstanceId != null) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.MinSize != null) {
        entries["MinSize"] = input.MinSize;
    }
    if (input.MaxSize != null) {
        entries["MaxSize"] = input.MaxSize;
    }
    if (input.DesiredCapacity != null) {
        entries["DesiredCapacity"] = input.DesiredCapacity;
    }
    if (input.DefaultCooldown != null) {
        entries["DefaultCooldown"] = input.DefaultCooldown;
    }
    if (input.AvailabilityZones != null) {
        const memberEntries = se_AvailabilityZones(input.AvailabilityZones, context);
        if (input.AvailabilityZones?.length === 0) {
            entries.AvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input.LoadBalancerNames != null) {
        const memberEntries = se_LoadBalancerNames(input.LoadBalancerNames, context);
        if (input.LoadBalancerNames?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.TargetGroupARNs != null) {
        const memberEntries = se_TargetGroupARNs(input.TargetGroupARNs, context);
        if (input.TargetGroupARNs?.length === 0) {
            entries.TargetGroupARNs = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupARNs.${key}`;
            entries[loc] = value;
        });
    }
    if (input.HealthCheckType != null) {
        entries["HealthCheckType"] = input.HealthCheckType;
    }
    if (input.HealthCheckGracePeriod != null) {
        entries["HealthCheckGracePeriod"] = input.HealthCheckGracePeriod;
    }
    if (input.PlacementGroup != null) {
        entries["PlacementGroup"] = input.PlacementGroup;
    }
    if (input.VPCZoneIdentifier != null) {
        entries["VPCZoneIdentifier"] = input.VPCZoneIdentifier;
    }
    if (input.TerminationPolicies != null) {
        const memberEntries = se_TerminationPolicies(input.TerminationPolicies, context);
        if (input.TerminationPolicies?.length === 0) {
            entries.TerminationPolicies = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TerminationPolicies.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NewInstancesProtectedFromScaleIn != null) {
        entries["NewInstancesProtectedFromScaleIn"] = input.NewInstancesProtectedFromScaleIn;
    }
    if (input.CapacityRebalance != null) {
        entries["CapacityRebalance"] = input.CapacityRebalance;
    }
    if (input.LifecycleHookSpecificationList != null) {
        const memberEntries = se_LifecycleHookSpecifications(input.LifecycleHookSpecificationList, context);
        if (input.LifecycleHookSpecificationList?.length === 0) {
            entries.LifecycleHookSpecificationList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LifecycleHookSpecificationList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Tags != null) {
        const memberEntries = se_Tags(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ServiceLinkedRoleARN != null) {
        entries["ServiceLinkedRoleARN"] = input.ServiceLinkedRoleARN;
    }
    if (input.MaxInstanceLifetime != null) {
        entries["MaxInstanceLifetime"] = input.MaxInstanceLifetime;
    }
    if (input.Context != null) {
        entries["Context"] = input.Context;
    }
    if (input.DesiredCapacityType != null) {
        entries["DesiredCapacityType"] = input.DesiredCapacityType;
    }
    if (input.DefaultInstanceWarmup != null) {
        entries["DefaultInstanceWarmup"] = input.DefaultInstanceWarmup;
    }
    if (input.TrafficSources != null) {
        const memberEntries = se_TrafficSources(input.TrafficSources, context);
        if (input.TrafficSources?.length === 0) {
            entries.TrafficSources = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficSources.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateLaunchConfigurationType = (input, context) => {
    const entries = {};
    if (input.LaunchConfigurationName != null) {
        entries["LaunchConfigurationName"] = input.LaunchConfigurationName;
    }
    if (input.ImageId != null) {
        entries["ImageId"] = input.ImageId;
    }
    if (input.KeyName != null) {
        entries["KeyName"] = input.KeyName;
    }
    if (input.SecurityGroups != null) {
        const memberEntries = se_SecurityGroups(input.SecurityGroups, context);
        if (input.SecurityGroups?.length === 0) {
            entries.SecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ClassicLinkVPCId != null) {
        entries["ClassicLinkVPCId"] = input.ClassicLinkVPCId;
    }
    if (input.ClassicLinkVPCSecurityGroups != null) {
        const memberEntries = se_ClassicLinkVPCSecurityGroups(input.ClassicLinkVPCSecurityGroups, context);
        if (input.ClassicLinkVPCSecurityGroups?.length === 0) {
            entries.ClassicLinkVPCSecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClassicLinkVPCSecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input.UserData != null) {
        entries["UserData"] = input.UserData;
    }
    if (input.InstanceId != null) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.InstanceType != null) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.KernelId != null) {
        entries["KernelId"] = input.KernelId;
    }
    if (input.RamdiskId != null) {
        entries["RamdiskId"] = input.RamdiskId;
    }
    if (input.BlockDeviceMappings != null) {
        const memberEntries = se_BlockDeviceMappings(input.BlockDeviceMappings, context);
        if (input.BlockDeviceMappings?.length === 0) {
            entries.BlockDeviceMappings = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BlockDeviceMappings.${key}`;
            entries[loc] = value;
        });
    }
    if (input.InstanceMonitoring != null) {
        const memberEntries = se_InstanceMonitoring(input.InstanceMonitoring, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceMonitoring.${key}`;
            entries[loc] = value;
        });
    }
    if (input.SpotPrice != null) {
        entries["SpotPrice"] = input.SpotPrice;
    }
    if (input.IamInstanceProfile != null) {
        entries["IamInstanceProfile"] = input.IamInstanceProfile;
    }
    if (input.EbsOptimized != null) {
        entries["EbsOptimized"] = input.EbsOptimized;
    }
    if (input.AssociatePublicIpAddress != null) {
        entries["AssociatePublicIpAddress"] = input.AssociatePublicIpAddress;
    }
    if (input.PlacementTenancy != null) {
        entries["PlacementTenancy"] = input.PlacementTenancy;
    }
    if (input.MetadataOptions != null) {
        const memberEntries = se_InstanceMetadataOptions(input.MetadataOptions, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetadataOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateOrUpdateTagsType = (input, context) => {
    const entries = {};
    if (input.Tags != null) {
        const memberEntries = se_Tags(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CustomizedMetricSpecification = (input, context) => {
    const entries = {};
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_MetricDimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Statistic != null) {
        entries["Statistic"] = input.Statistic;
    }
    if (input.Unit != null) {
        entries["Unit"] = input.Unit;
    }
    if (input.Metrics != null) {
        const memberEntries = se_TargetTrackingMetricDataQueries(input.Metrics, context);
        if (input.Metrics?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteAutoScalingGroupType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ForceDelete != null) {
        entries["ForceDelete"] = input.ForceDelete;
    }
    return entries;
};
const se_DeleteLifecycleHookType = (input, context) => {
    const entries = {};
    if (input.LifecycleHookName != null) {
        entries["LifecycleHookName"] = input.LifecycleHookName;
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    return entries;
};
const se_DeleteNotificationConfigurationType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.TopicARN != null) {
        entries["TopicARN"] = input.TopicARN;
    }
    return entries;
};
const se_DeletePolicyType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_DeleteScheduledActionType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ScheduledActionName != null) {
        entries["ScheduledActionName"] = input.ScheduledActionName;
    }
    return entries;
};
const se_DeleteTagsType = (input, context) => {
    const entries = {};
    if (input.Tags != null) {
        const memberEntries = se_Tags(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteWarmPoolType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ForceDelete != null) {
        entries["ForceDelete"] = input.ForceDelete;
    }
    return entries;
};
const se_DescribeAutoScalingInstancesType = (input, context) => {
    const entries = {};
    if (input.InstanceIds != null) {
        const memberEntries = se_InstanceIds(input.InstanceIds, context);
        if (input.InstanceIds?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const se_DescribeInstanceRefreshesType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.InstanceRefreshIds != null) {
        const memberEntries = se_InstanceRefreshIds(input.InstanceRefreshIds, context);
        if (input.InstanceRefreshIds?.length === 0) {
            entries.InstanceRefreshIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRefreshIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    return entries;
};
const se_DescribeLifecycleHooksType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.LifecycleHookNames != null) {
        const memberEntries = se_LifecycleHookNames(input.LifecycleHookNames, context);
        if (input.LifecycleHookNames?.length === 0) {
            entries.LifecycleHookNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LifecycleHookNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeLoadBalancersRequest = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    return entries;
};
const se_DescribeLoadBalancerTargetGroupsRequest = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    return entries;
};
const se_DescribeNotificationConfigurationsType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupNames != null) {
        const memberEntries = se_AutoScalingGroupNames(input.AutoScalingGroupNames, context);
        if (input.AutoScalingGroupNames?.length === 0) {
            entries.AutoScalingGroupNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AutoScalingGroupNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    return entries;
};
const se_DescribePoliciesType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.PolicyNames != null) {
        const memberEntries = se_PolicyNames(input.PolicyNames, context);
        if (input.PolicyNames?.length === 0) {
            entries.PolicyNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.PolicyTypes != null) {
        const memberEntries = se_PolicyTypes(input.PolicyTypes, context);
        if (input.PolicyTypes?.length === 0) {
            entries.PolicyTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    return entries;
};
const se_DescribeScalingActivitiesType = (input, context) => {
    const entries = {};
    if (input.ActivityIds != null) {
        const memberEntries = se_ActivityIds(input.ActivityIds, context);
        if (input.ActivityIds?.length === 0) {
            entries.ActivityIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ActivityIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.IncludeDeletedGroups != null) {
        entries["IncludeDeletedGroups"] = input.IncludeDeletedGroups;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const se_DescribeScheduledActionsType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ScheduledActionNames != null) {
        const memberEntries = se_ScheduledActionNames(input.ScheduledActionNames, context);
        if (input.ScheduledActionNames?.length === 0) {
            entries.ScheduledActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScheduledActionNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.StartTime != null) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.EndTime != null) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    return entries;
};
const se_DescribeTagsType = (input, context) => {
    const entries = {};
    if (input.Filters != null) {
        const memberEntries = se_Filters(input.Filters, context);
        if (input.Filters?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    return entries;
};
const se_DescribeTrafficSourcesRequest = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.TrafficSourceType != null) {
        entries["TrafficSourceType"] = input.TrafficSourceType;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    return entries;
};
const se_DescribeWarmPoolType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const se_DesiredConfiguration = (input, context) => {
    const entries = {};
    if (input.LaunchTemplate != null) {
        const memberEntries = se_LaunchTemplateSpecification(input.LaunchTemplate, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MixedInstancesPolicy != null) {
        const memberEntries = se_MixedInstancesPolicy(input.MixedInstancesPolicy, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MixedInstancesPolicy.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DetachInstancesQuery = (input, context) => {
    const entries = {};
    if (input.InstanceIds != null) {
        const memberEntries = se_InstanceIds(input.InstanceIds, context);
        if (input.InstanceIds?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ShouldDecrementDesiredCapacity != null) {
        entries["ShouldDecrementDesiredCapacity"] = input.ShouldDecrementDesiredCapacity;
    }
    return entries;
};
const se_DetachLoadBalancersType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.LoadBalancerNames != null) {
        const memberEntries = se_LoadBalancerNames(input.LoadBalancerNames, context);
        if (input.LoadBalancerNames?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DetachLoadBalancerTargetGroupsType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.TargetGroupARNs != null) {
        const memberEntries = se_TargetGroupARNs(input.TargetGroupARNs, context);
        if (input.TargetGroupARNs?.length === 0) {
            entries.TargetGroupARNs = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupARNs.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DetachTrafficSourcesType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.TrafficSources != null) {
        const memberEntries = se_TrafficSources(input.TrafficSources, context);
        if (input.TrafficSources?.length === 0) {
            entries.TrafficSources = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TrafficSources.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DisableMetricsCollectionQuery = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.Metrics != null) {
        const memberEntries = se_Metrics(input.Metrics, context);
        if (input.Metrics?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Ebs = (input, context) => {
    const entries = {};
    if (input.SnapshotId != null) {
        entries["SnapshotId"] = input.SnapshotId;
    }
    if (input.VolumeSize != null) {
        entries["VolumeSize"] = input.VolumeSize;
    }
    if (input.VolumeType != null) {
        entries["VolumeType"] = input.VolumeType;
    }
    if (input.DeleteOnTermination != null) {
        entries["DeleteOnTermination"] = input.DeleteOnTermination;
    }
    if (input.Iops != null) {
        entries["Iops"] = input.Iops;
    }
    if (input.Encrypted != null) {
        entries["Encrypted"] = input.Encrypted;
    }
    if (input.Throughput != null) {
        entries["Throughput"] = input.Throughput;
    }
    return entries;
};
const se_EnableMetricsCollectionQuery = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.Metrics != null) {
        const memberEntries = se_Metrics(input.Metrics, context);
        if (input.Metrics?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Granularity != null) {
        entries["Granularity"] = input.Granularity;
    }
    return entries;
};
const se_EnterStandbyQuery = (input, context) => {
    const entries = {};
    if (input.InstanceIds != null) {
        const memberEntries = se_InstanceIds(input.InstanceIds, context);
        if (input.InstanceIds?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ShouldDecrementDesiredCapacity != null) {
        entries["ShouldDecrementDesiredCapacity"] = input.ShouldDecrementDesiredCapacity;
    }
    return entries;
};
const se_ExcludedInstanceTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ExecutePolicyType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.HonorCooldown != null) {
        entries["HonorCooldown"] = input.HonorCooldown;
    }
    if (input.MetricValue != null) {
        entries["MetricValue"] = __serializeFloat(input.MetricValue);
    }
    if (input.BreachThreshold != null) {
        entries["BreachThreshold"] = __serializeFloat(input.BreachThreshold);
    }
    return entries;
};
const se_ExitStandbyQuery = (input, context) => {
    const entries = {};
    if (input.InstanceIds != null) {
        const memberEntries = se_InstanceIds(input.InstanceIds, context);
        if (input.InstanceIds?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    return entries;
};
const se_Filter = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Values != null) {
        const memberEntries = se_Values(input.Values, context);
        if (input.Values?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Filters = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Filter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_GetPredictiveScalingForecastType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.StartTime != null) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.EndTime != null) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const se_InstanceGenerations = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceMetadataOptions = (input, context) => {
    const entries = {};
    if (input.HttpTokens != null) {
        entries["HttpTokens"] = input.HttpTokens;
    }
    if (input.HttpPutResponseHopLimit != null) {
        entries["HttpPutResponseHopLimit"] = input.HttpPutResponseHopLimit;
    }
    if (input.HttpEndpoint != null) {
        entries["HttpEndpoint"] = input.HttpEndpoint;
    }
    return entries;
};
const se_InstanceMonitoring = (input, context) => {
    const entries = {};
    if (input.Enabled != null) {
        entries["Enabled"] = input.Enabled;
    }
    return entries;
};
const se_InstanceRefreshIds = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InstanceRequirements = (input, context) => {
    const entries = {};
    if (input.VCpuCount != null) {
        const memberEntries = se_VCpuCountRequest(input.VCpuCount, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VCpuCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MemoryMiB != null) {
        const memberEntries = se_MemoryMiBRequest(input.MemoryMiB, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MemoryMiB.${key}`;
            entries[loc] = value;
        });
    }
    if (input.CpuManufacturers != null) {
        const memberEntries = se_CpuManufacturers(input.CpuManufacturers, context);
        if (input.CpuManufacturers?.length === 0) {
            entries.CpuManufacturers = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CpuManufacturers.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MemoryGiBPerVCpu != null) {
        const memberEntries = se_MemoryGiBPerVCpuRequest(input.MemoryGiBPerVCpu, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MemoryGiBPerVCpu.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ExcludedInstanceTypes != null) {
        const memberEntries = se_ExcludedInstanceTypes(input.ExcludedInstanceTypes, context);
        if (input.ExcludedInstanceTypes?.length === 0) {
            entries.ExcludedInstanceTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludedInstanceTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input.InstanceGenerations != null) {
        const memberEntries = se_InstanceGenerations(input.InstanceGenerations, context);
        if (input.InstanceGenerations?.length === 0) {
            entries.InstanceGenerations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceGenerations.${key}`;
            entries[loc] = value;
        });
    }
    if (input.SpotMaxPricePercentageOverLowestPrice != null) {
        entries["SpotMaxPricePercentageOverLowestPrice"] = input.SpotMaxPricePercentageOverLowestPrice;
    }
    if (input.OnDemandMaxPricePercentageOverLowestPrice != null) {
        entries["OnDemandMaxPricePercentageOverLowestPrice"] = input.OnDemandMaxPricePercentageOverLowestPrice;
    }
    if (input.BareMetal != null) {
        entries["BareMetal"] = input.BareMetal;
    }
    if (input.BurstablePerformance != null) {
        entries["BurstablePerformance"] = input.BurstablePerformance;
    }
    if (input.RequireHibernateSupport != null) {
        entries["RequireHibernateSupport"] = input.RequireHibernateSupport;
    }
    if (input.NetworkInterfaceCount != null) {
        const memberEntries = se_NetworkInterfaceCountRequest(input.NetworkInterfaceCount, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkInterfaceCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input.LocalStorage != null) {
        entries["LocalStorage"] = input.LocalStorage;
    }
    if (input.LocalStorageTypes != null) {
        const memberEntries = se_LocalStorageTypes(input.LocalStorageTypes, context);
        if (input.LocalStorageTypes?.length === 0) {
            entries.LocalStorageTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LocalStorageTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input.TotalLocalStorageGB != null) {
        const memberEntries = se_TotalLocalStorageGBRequest(input.TotalLocalStorageGB, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TotalLocalStorageGB.${key}`;
            entries[loc] = value;
        });
    }
    if (input.BaselineEbsBandwidthMbps != null) {
        const memberEntries = se_BaselineEbsBandwidthMbpsRequest(input.BaselineEbsBandwidthMbps, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `BaselineEbsBandwidthMbps.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AcceleratorTypes != null) {
        const memberEntries = se_AcceleratorTypes(input.AcceleratorTypes, context);
        if (input.AcceleratorTypes?.length === 0) {
            entries.AcceleratorTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AcceleratorCount != null) {
        const memberEntries = se_AcceleratorCountRequest(input.AcceleratorCount, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorCount.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AcceleratorManufacturers != null) {
        const memberEntries = se_AcceleratorManufacturers(input.AcceleratorManufacturers, context);
        if (input.AcceleratorManufacturers?.length === 0) {
            entries.AcceleratorManufacturers = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorManufacturers.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AcceleratorNames != null) {
        const memberEntries = se_AcceleratorNames(input.AcceleratorNames, context);
        if (input.AcceleratorNames?.length === 0) {
            entries.AcceleratorNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AcceleratorTotalMemoryMiB != null) {
        const memberEntries = se_AcceleratorTotalMemoryMiBRequest(input.AcceleratorTotalMemoryMiB, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AcceleratorTotalMemoryMiB.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NetworkBandwidthGbps != null) {
        const memberEntries = se_NetworkBandwidthGbpsRequest(input.NetworkBandwidthGbps, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NetworkBandwidthGbps.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AllowedInstanceTypes != null) {
        const memberEntries = se_AllowedInstanceTypes(input.AllowedInstanceTypes, context);
        if (input.AllowedInstanceTypes?.length === 0) {
            entries.AllowedInstanceTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AllowedInstanceTypes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_InstanceReusePolicy = (input, context) => {
    const entries = {};
    if (input.ReuseOnScaleIn != null) {
        entries["ReuseOnScaleIn"] = input.ReuseOnScaleIn;
    }
    return entries;
};
const se_InstancesDistribution = (input, context) => {
    const entries = {};
    if (input.OnDemandAllocationStrategy != null) {
        entries["OnDemandAllocationStrategy"] = input.OnDemandAllocationStrategy;
    }
    if (input.OnDemandBaseCapacity != null) {
        entries["OnDemandBaseCapacity"] = input.OnDemandBaseCapacity;
    }
    if (input.OnDemandPercentageAboveBaseCapacity != null) {
        entries["OnDemandPercentageAboveBaseCapacity"] = input.OnDemandPercentageAboveBaseCapacity;
    }
    if (input.SpotAllocationStrategy != null) {
        entries["SpotAllocationStrategy"] = input.SpotAllocationStrategy;
    }
    if (input.SpotInstancePools != null) {
        entries["SpotInstancePools"] = input.SpotInstancePools;
    }
    if (input.SpotMaxPrice != null) {
        entries["SpotMaxPrice"] = input.SpotMaxPrice;
    }
    return entries;
};
const se_LaunchConfigurationNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LaunchConfigurationNamesType = (input, context) => {
    const entries = {};
    if (input.LaunchConfigurationNames != null) {
        const memberEntries = se_LaunchConfigurationNames(input.LaunchConfigurationNames, context);
        if (input.LaunchConfigurationNames?.length === 0) {
            entries.LaunchConfigurationNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchConfigurationNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    return entries;
};
const se_LaunchConfigurationNameType = (input, context) => {
    const entries = {};
    if (input.LaunchConfigurationName != null) {
        entries["LaunchConfigurationName"] = input.LaunchConfigurationName;
    }
    return entries;
};
const se_LaunchTemplate = (input, context) => {
    const entries = {};
    if (input.LaunchTemplateSpecification != null) {
        const memberEntries = se_LaunchTemplateSpecification(input.LaunchTemplateSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Overrides != null) {
        const memberEntries = se_Overrides(input.Overrides, context);
        if (input.Overrides?.length === 0) {
            entries.Overrides = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Overrides.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateOverrides = (input, context) => {
    const entries = {};
    if (input.InstanceType != null) {
        entries["InstanceType"] = input.InstanceType;
    }
    if (input.WeightedCapacity != null) {
        entries["WeightedCapacity"] = input.WeightedCapacity;
    }
    if (input.LaunchTemplateSpecification != null) {
        const memberEntries = se_LaunchTemplateSpecification(input.LaunchTemplateSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplateSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input.InstanceRequirements != null) {
        const memberEntries = se_InstanceRequirements(input.InstanceRequirements, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceRequirements.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LaunchTemplateSpecification = (input, context) => {
    const entries = {};
    if (input.LaunchTemplateId != null) {
        entries["LaunchTemplateId"] = input.LaunchTemplateId;
    }
    if (input.LaunchTemplateName != null) {
        entries["LaunchTemplateName"] = input.LaunchTemplateName;
    }
    if (input.Version != null) {
        entries["Version"] = input.Version;
    }
    return entries;
};
const se_LifecycleHookNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LifecycleHookSpecification = (input, context) => {
    const entries = {};
    if (input.LifecycleHookName != null) {
        entries["LifecycleHookName"] = input.LifecycleHookName;
    }
    if (input.LifecycleTransition != null) {
        entries["LifecycleTransition"] = input.LifecycleTransition;
    }
    if (input.NotificationMetadata != null) {
        entries["NotificationMetadata"] = input.NotificationMetadata;
    }
    if (input.HeartbeatTimeout != null) {
        entries["HeartbeatTimeout"] = input.HeartbeatTimeout;
    }
    if (input.DefaultResult != null) {
        entries["DefaultResult"] = input.DefaultResult;
    }
    if (input.NotificationTargetARN != null) {
        entries["NotificationTargetARN"] = input.NotificationTargetARN;
    }
    if (input.RoleARN != null) {
        entries["RoleARN"] = input.RoleARN;
    }
    return entries;
};
const se_LifecycleHookSpecifications = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LifecycleHookSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LoadBalancerNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LocalStorageTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MemoryGiBPerVCpuRequest = (input, context) => {
    const entries = {};
    if (input.Min != null) {
        entries["Min"] = __serializeFloat(input.Min);
    }
    if (input.Max != null) {
        entries["Max"] = __serializeFloat(input.Max);
    }
    return entries;
};
const se_MemoryMiBRequest = (input, context) => {
    const entries = {};
    if (input.Min != null) {
        entries["Min"] = input.Min;
    }
    if (input.Max != null) {
        entries["Max"] = input.Max;
    }
    return entries;
};
const se_Metric = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_MetricDimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricDataQueries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDataQuery(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricDataQuery = (input, context) => {
    const entries = {};
    if (input.Id != null) {
        entries["Id"] = input.Id;
    }
    if (input.Expression != null) {
        entries["Expression"] = input.Expression;
    }
    if (input.MetricStat != null) {
        const memberEntries = se_MetricStat(input.MetricStat, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricStat.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Label != null) {
        entries["Label"] = input.Label;
    }
    if (input.ReturnData != null) {
        entries["ReturnData"] = input.ReturnData;
    }
    return entries;
};
const se_MetricDimension = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_MetricDimensions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDimension(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Metrics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStat = (input, context) => {
    const entries = {};
    if (input.Metric != null) {
        const memberEntries = se_Metric(input.Metric, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metric.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Stat != null) {
        entries["Stat"] = input.Stat;
    }
    if (input.Unit != null) {
        entries["Unit"] = input.Unit;
    }
    return entries;
};
const se_MixedInstancesPolicy = (input, context) => {
    const entries = {};
    if (input.LaunchTemplate != null) {
        const memberEntries = se_LaunchTemplate(input.LaunchTemplate, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input.InstancesDistribution != null) {
        const memberEntries = se_InstancesDistribution(input.InstancesDistribution, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstancesDistribution.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_NetworkBandwidthGbpsRequest = (input, context) => {
    const entries = {};
    if (input.Min != null) {
        entries["Min"] = __serializeFloat(input.Min);
    }
    if (input.Max != null) {
        entries["Max"] = __serializeFloat(input.Max);
    }
    return entries;
};
const se_NetworkInterfaceCountRequest = (input, context) => {
    const entries = {};
    if (input.Min != null) {
        entries["Min"] = input.Min;
    }
    if (input.Max != null) {
        entries["Max"] = input.Max;
    }
    return entries;
};
const se_Overrides = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LaunchTemplateOverrides(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PolicyNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PolicyTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PredefinedMetricSpecification = (input, context) => {
    const entries = {};
    if (input.PredefinedMetricType != null) {
        entries["PredefinedMetricType"] = input.PredefinedMetricType;
    }
    if (input.ResourceLabel != null) {
        entries["ResourceLabel"] = input.ResourceLabel;
    }
    return entries;
};
const se_PredictiveScalingConfiguration = (input, context) => {
    const entries = {};
    if (input.MetricSpecifications != null) {
        const memberEntries = se_PredictiveScalingMetricSpecifications(input.MetricSpecifications, context);
        if (input.MetricSpecifications?.length === 0) {
            entries.MetricSpecifications = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricSpecifications.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Mode != null) {
        entries["Mode"] = input.Mode;
    }
    if (input.SchedulingBufferTime != null) {
        entries["SchedulingBufferTime"] = input.SchedulingBufferTime;
    }
    if (input.MaxCapacityBreachBehavior != null) {
        entries["MaxCapacityBreachBehavior"] = input.MaxCapacityBreachBehavior;
    }
    if (input.MaxCapacityBuffer != null) {
        entries["MaxCapacityBuffer"] = input.MaxCapacityBuffer;
    }
    return entries;
};
const se_PredictiveScalingCustomizedCapacityMetric = (input, context) => {
    const entries = {};
    if (input.MetricDataQueries != null) {
        const memberEntries = se_MetricDataQueries(input.MetricDataQueries, context);
        if (input.MetricDataQueries?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PredictiveScalingCustomizedLoadMetric = (input, context) => {
    const entries = {};
    if (input.MetricDataQueries != null) {
        const memberEntries = se_MetricDataQueries(input.MetricDataQueries, context);
        if (input.MetricDataQueries?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PredictiveScalingCustomizedScalingMetric = (input, context) => {
    const entries = {};
    if (input.MetricDataQueries != null) {
        const memberEntries = se_MetricDataQueries(input.MetricDataQueries, context);
        if (input.MetricDataQueries?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PredictiveScalingMetricSpecification = (input, context) => {
    const entries = {};
    if (input.TargetValue != null) {
        entries["TargetValue"] = __serializeFloat(input.TargetValue);
    }
    if (input.PredefinedMetricPairSpecification != null) {
        const memberEntries = se_PredictiveScalingPredefinedMetricPair(input.PredefinedMetricPairSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredefinedMetricPairSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input.PredefinedScalingMetricSpecification != null) {
        const memberEntries = se_PredictiveScalingPredefinedScalingMetric(input.PredefinedScalingMetricSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredefinedScalingMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input.PredefinedLoadMetricSpecification != null) {
        const memberEntries = se_PredictiveScalingPredefinedLoadMetric(input.PredefinedLoadMetricSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredefinedLoadMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input.CustomizedScalingMetricSpecification != null) {
        const memberEntries = se_PredictiveScalingCustomizedScalingMetric(input.CustomizedScalingMetricSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomizedScalingMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input.CustomizedLoadMetricSpecification != null) {
        const memberEntries = se_PredictiveScalingCustomizedLoadMetric(input.CustomizedLoadMetricSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomizedLoadMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input.CustomizedCapacityMetricSpecification != null) {
        const memberEntries = se_PredictiveScalingCustomizedCapacityMetric(input.CustomizedCapacityMetricSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomizedCapacityMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PredictiveScalingMetricSpecifications = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PredictiveScalingMetricSpecification(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PredictiveScalingPredefinedLoadMetric = (input, context) => {
    const entries = {};
    if (input.PredefinedMetricType != null) {
        entries["PredefinedMetricType"] = input.PredefinedMetricType;
    }
    if (input.ResourceLabel != null) {
        entries["ResourceLabel"] = input.ResourceLabel;
    }
    return entries;
};
const se_PredictiveScalingPredefinedMetricPair = (input, context) => {
    const entries = {};
    if (input.PredefinedMetricType != null) {
        entries["PredefinedMetricType"] = input.PredefinedMetricType;
    }
    if (input.ResourceLabel != null) {
        entries["ResourceLabel"] = input.ResourceLabel;
    }
    return entries;
};
const se_PredictiveScalingPredefinedScalingMetric = (input, context) => {
    const entries = {};
    if (input.PredefinedMetricType != null) {
        entries["PredefinedMetricType"] = input.PredefinedMetricType;
    }
    if (input.ResourceLabel != null) {
        entries["ResourceLabel"] = input.ResourceLabel;
    }
    return entries;
};
const se_ProcessNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PutLifecycleHookType = (input, context) => {
    const entries = {};
    if (input.LifecycleHookName != null) {
        entries["LifecycleHookName"] = input.LifecycleHookName;
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.LifecycleTransition != null) {
        entries["LifecycleTransition"] = input.LifecycleTransition;
    }
    if (input.RoleARN != null) {
        entries["RoleARN"] = input.RoleARN;
    }
    if (input.NotificationTargetARN != null) {
        entries["NotificationTargetARN"] = input.NotificationTargetARN;
    }
    if (input.NotificationMetadata != null) {
        entries["NotificationMetadata"] = input.NotificationMetadata;
    }
    if (input.HeartbeatTimeout != null) {
        entries["HeartbeatTimeout"] = input.HeartbeatTimeout;
    }
    if (input.DefaultResult != null) {
        entries["DefaultResult"] = input.DefaultResult;
    }
    return entries;
};
const se_PutNotificationConfigurationType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.TopicARN != null) {
        entries["TopicARN"] = input.TopicARN;
    }
    if (input.NotificationTypes != null) {
        const memberEntries = se_AutoScalingNotificationTypes(input.NotificationTypes, context);
        if (input.NotificationTypes?.length === 0) {
            entries.NotificationTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `NotificationTypes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutScalingPolicyType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.PolicyType != null) {
        entries["PolicyType"] = input.PolicyType;
    }
    if (input.AdjustmentType != null) {
        entries["AdjustmentType"] = input.AdjustmentType;
    }
    if (input.MinAdjustmentStep != null) {
        entries["MinAdjustmentStep"] = input.MinAdjustmentStep;
    }
    if (input.MinAdjustmentMagnitude != null) {
        entries["MinAdjustmentMagnitude"] = input.MinAdjustmentMagnitude;
    }
    if (input.ScalingAdjustment != null) {
        entries["ScalingAdjustment"] = input.ScalingAdjustment;
    }
    if (input.Cooldown != null) {
        entries["Cooldown"] = input.Cooldown;
    }
    if (input.MetricAggregationType != null) {
        entries["MetricAggregationType"] = input.MetricAggregationType;
    }
    if (input.StepAdjustments != null) {
        const memberEntries = se_StepAdjustments(input.StepAdjustments, context);
        if (input.StepAdjustments?.length === 0) {
            entries.StepAdjustments = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `StepAdjustments.${key}`;
            entries[loc] = value;
        });
    }
    if (input.EstimatedInstanceWarmup != null) {
        entries["EstimatedInstanceWarmup"] = input.EstimatedInstanceWarmup;
    }
    if (input.TargetTrackingConfiguration != null) {
        const memberEntries = se_TargetTrackingConfiguration(input.TargetTrackingConfiguration, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetTrackingConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Enabled != null) {
        entries["Enabled"] = input.Enabled;
    }
    if (input.PredictiveScalingConfiguration != null) {
        const memberEntries = se_PredictiveScalingConfiguration(input.PredictiveScalingConfiguration, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredictiveScalingConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutScheduledUpdateGroupActionType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ScheduledActionName != null) {
        entries["ScheduledActionName"] = input.ScheduledActionName;
    }
    if (input.Time != null) {
        entries["Time"] = input.Time.toISOString().split(".")[0] + "Z";
    }
    if (input.StartTime != null) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.EndTime != null) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    if (input.Recurrence != null) {
        entries["Recurrence"] = input.Recurrence;
    }
    if (input.MinSize != null) {
        entries["MinSize"] = input.MinSize;
    }
    if (input.MaxSize != null) {
        entries["MaxSize"] = input.MaxSize;
    }
    if (input.DesiredCapacity != null) {
        entries["DesiredCapacity"] = input.DesiredCapacity;
    }
    if (input.TimeZone != null) {
        entries["TimeZone"] = input.TimeZone;
    }
    return entries;
};
const se_PutWarmPoolType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.MaxGroupPreparedCapacity != null) {
        entries["MaxGroupPreparedCapacity"] = input.MaxGroupPreparedCapacity;
    }
    if (input.MinSize != null) {
        entries["MinSize"] = input.MinSize;
    }
    if (input.PoolState != null) {
        entries["PoolState"] = input.PoolState;
    }
    if (input.InstanceReusePolicy != null) {
        const memberEntries = se_InstanceReusePolicy(input.InstanceReusePolicy, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceReusePolicy.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RecordLifecycleActionHeartbeatType = (input, context) => {
    const entries = {};
    if (input.LifecycleHookName != null) {
        entries["LifecycleHookName"] = input.LifecycleHookName;
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.LifecycleActionToken != null) {
        entries["LifecycleActionToken"] = input.LifecycleActionToken;
    }
    if (input.InstanceId != null) {
        entries["InstanceId"] = input.InstanceId;
    }
    return entries;
};
const se_RefreshPreferences = (input, context) => {
    const entries = {};
    if (input.MinHealthyPercentage != null) {
        entries["MinHealthyPercentage"] = input.MinHealthyPercentage;
    }
    if (input.InstanceWarmup != null) {
        entries["InstanceWarmup"] = input.InstanceWarmup;
    }
    if (input.CheckpointPercentages != null) {
        const memberEntries = se_CheckpointPercentages(input.CheckpointPercentages, context);
        if (input.CheckpointPercentages?.length === 0) {
            entries.CheckpointPercentages = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CheckpointPercentages.${key}`;
            entries[loc] = value;
        });
    }
    if (input.CheckpointDelay != null) {
        entries["CheckpointDelay"] = input.CheckpointDelay;
    }
    if (input.SkipMatching != null) {
        entries["SkipMatching"] = input.SkipMatching;
    }
    if (input.AutoRollback != null) {
        entries["AutoRollback"] = input.AutoRollback;
    }
    if (input.ScaleInProtectedInstances != null) {
        entries["ScaleInProtectedInstances"] = input.ScaleInProtectedInstances;
    }
    if (input.StandbyInstances != null) {
        entries["StandbyInstances"] = input.StandbyInstances;
    }
    return entries;
};
const se_RollbackInstanceRefreshType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    return entries;
};
const se_ScalingProcessQuery = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ScalingProcesses != null) {
        const memberEntries = se_ProcessNames(input.ScalingProcesses, context);
        if (input.ScalingProcesses?.length === 0) {
            entries.ScalingProcesses = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScalingProcesses.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ScheduledActionNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ScheduledUpdateGroupActionRequest = (input, context) => {
    const entries = {};
    if (input.ScheduledActionName != null) {
        entries["ScheduledActionName"] = input.ScheduledActionName;
    }
    if (input.StartTime != null) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.EndTime != null) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    if (input.Recurrence != null) {
        entries["Recurrence"] = input.Recurrence;
    }
    if (input.MinSize != null) {
        entries["MinSize"] = input.MinSize;
    }
    if (input.MaxSize != null) {
        entries["MaxSize"] = input.MaxSize;
    }
    if (input.DesiredCapacity != null) {
        entries["DesiredCapacity"] = input.DesiredCapacity;
    }
    if (input.TimeZone != null) {
        entries["TimeZone"] = input.TimeZone;
    }
    return entries;
};
const se_ScheduledUpdateGroupActionRequests = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ScheduledUpdateGroupActionRequest(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_SecurityGroups = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetDesiredCapacityType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.DesiredCapacity != null) {
        entries["DesiredCapacity"] = input.DesiredCapacity;
    }
    if (input.HonorCooldown != null) {
        entries["HonorCooldown"] = input.HonorCooldown;
    }
    return entries;
};
const se_SetInstanceHealthQuery = (input, context) => {
    const entries = {};
    if (input.InstanceId != null) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.HealthStatus != null) {
        entries["HealthStatus"] = input.HealthStatus;
    }
    if (input.ShouldRespectGracePeriod != null) {
        entries["ShouldRespectGracePeriod"] = input.ShouldRespectGracePeriod;
    }
    return entries;
};
const se_SetInstanceProtectionQuery = (input, context) => {
    const entries = {};
    if (input.InstanceIds != null) {
        const memberEntries = se_InstanceIds(input.InstanceIds, context);
        if (input.InstanceIds?.length === 0) {
            entries.InstanceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InstanceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.ProtectedFromScaleIn != null) {
        entries["ProtectedFromScaleIn"] = input.ProtectedFromScaleIn;
    }
    return entries;
};
const se_StartInstanceRefreshType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.Strategy != null) {
        entries["Strategy"] = input.Strategy;
    }
    if (input.DesiredConfiguration != null) {
        const memberEntries = se_DesiredConfiguration(input.DesiredConfiguration, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DesiredConfiguration.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Preferences != null) {
        const memberEntries = se_RefreshPreferences(input.Preferences, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Preferences.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_StepAdjustment = (input, context) => {
    const entries = {};
    if (input.MetricIntervalLowerBound != null) {
        entries["MetricIntervalLowerBound"] = __serializeFloat(input.MetricIntervalLowerBound);
    }
    if (input.MetricIntervalUpperBound != null) {
        entries["MetricIntervalUpperBound"] = __serializeFloat(input.MetricIntervalUpperBound);
    }
    if (input.ScalingAdjustment != null) {
        entries["ScalingAdjustment"] = input.ScalingAdjustment;
    }
    return entries;
};
const se_StepAdjustments = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_StepAdjustment(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input.ResourceId != null) {
        entries["ResourceId"] = input.ResourceId;
    }
    if (input.ResourceType != null) {
        entries["ResourceType"] = input.ResourceType;
    }
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    if (input.PropagateAtLaunch != null) {
        entries["PropagateAtLaunch"] = input.PropagateAtLaunch;
    }
    return entries;
};
const se_Tags = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroupARNs = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TargetTrackingConfiguration = (input, context) => {
    const entries = {};
    if (input.PredefinedMetricSpecification != null) {
        const memberEntries = se_PredefinedMetricSpecification(input.PredefinedMetricSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PredefinedMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input.CustomizedMetricSpecification != null) {
        const memberEntries = se_CustomizedMetricSpecification(input.CustomizedMetricSpecification, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CustomizedMetricSpecification.${key}`;
            entries[loc] = value;
        });
    }
    if (input.TargetValue != null) {
        entries["TargetValue"] = __serializeFloat(input.TargetValue);
    }
    if (input.DisableScaleIn != null) {
        entries["DisableScaleIn"] = input.DisableScaleIn;
    }
    return entries;
};
const se_TargetTrackingMetricDataQueries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetTrackingMetricDataQuery(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetTrackingMetricDataQuery = (input, context) => {
    const entries = {};
    if (input.Id != null) {
        entries["Id"] = input.Id;
    }
    if (input.Expression != null) {
        entries["Expression"] = input.Expression;
    }
    if (input.MetricStat != null) {
        const memberEntries = se_TargetTrackingMetricStat(input.MetricStat, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricStat.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Label != null) {
        entries["Label"] = input.Label;
    }
    if (input.ReturnData != null) {
        entries["ReturnData"] = input.ReturnData;
    }
    return entries;
};
const se_TargetTrackingMetricStat = (input, context) => {
    const entries = {};
    if (input.Metric != null) {
        const memberEntries = se_Metric(input.Metric, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metric.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Stat != null) {
        entries["Stat"] = input.Stat;
    }
    if (input.Unit != null) {
        entries["Unit"] = input.Unit;
    }
    return entries;
};
const se_TerminateInstanceInAutoScalingGroupType = (input, context) => {
    const entries = {};
    if (input.InstanceId != null) {
        entries["InstanceId"] = input.InstanceId;
    }
    if (input.ShouldDecrementDesiredCapacity != null) {
        entries["ShouldDecrementDesiredCapacity"] = input.ShouldDecrementDesiredCapacity;
    }
    return entries;
};
const se_TerminationPolicies = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TotalLocalStorageGBRequest = (input, context) => {
    const entries = {};
    if (input.Min != null) {
        entries["Min"] = __serializeFloat(input.Min);
    }
    if (input.Max != null) {
        entries["Max"] = __serializeFloat(input.Max);
    }
    return entries;
};
const se_TrafficSourceIdentifier = (input, context) => {
    const entries = {};
    if (input.Identifier != null) {
        entries["Identifier"] = input.Identifier;
    }
    if (input.Type != null) {
        entries["Type"] = input.Type;
    }
    return entries;
};
const se_TrafficSources = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TrafficSourceIdentifier(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_UpdateAutoScalingGroupType = (input, context) => {
    const entries = {};
    if (input.AutoScalingGroupName != null) {
        entries["AutoScalingGroupName"] = input.AutoScalingGroupName;
    }
    if (input.LaunchConfigurationName != null) {
        entries["LaunchConfigurationName"] = input.LaunchConfigurationName;
    }
    if (input.LaunchTemplate != null) {
        const memberEntries = se_LaunchTemplateSpecification(input.LaunchTemplate, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LaunchTemplate.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MixedInstancesPolicy != null) {
        const memberEntries = se_MixedInstancesPolicy(input.MixedInstancesPolicy, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MixedInstancesPolicy.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MinSize != null) {
        entries["MinSize"] = input.MinSize;
    }
    if (input.MaxSize != null) {
        entries["MaxSize"] = input.MaxSize;
    }
    if (input.DesiredCapacity != null) {
        entries["DesiredCapacity"] = input.DesiredCapacity;
    }
    if (input.DefaultCooldown != null) {
        entries["DefaultCooldown"] = input.DefaultCooldown;
    }
    if (input.AvailabilityZones != null) {
        const memberEntries = se_AvailabilityZones(input.AvailabilityZones, context);
        if (input.AvailabilityZones?.length === 0) {
            entries.AvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input.HealthCheckType != null) {
        entries["HealthCheckType"] = input.HealthCheckType;
    }
    if (input.HealthCheckGracePeriod != null) {
        entries["HealthCheckGracePeriod"] = input.HealthCheckGracePeriod;
    }
    if (input.PlacementGroup != null) {
        entries["PlacementGroup"] = input.PlacementGroup;
    }
    if (input.VPCZoneIdentifier != null) {
        entries["VPCZoneIdentifier"] = input.VPCZoneIdentifier;
    }
    if (input.TerminationPolicies != null) {
        const memberEntries = se_TerminationPolicies(input.TerminationPolicies, context);
        if (input.TerminationPolicies?.length === 0) {
            entries.TerminationPolicies = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TerminationPolicies.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NewInstancesProtectedFromScaleIn != null) {
        entries["NewInstancesProtectedFromScaleIn"] = input.NewInstancesProtectedFromScaleIn;
    }
    if (input.ServiceLinkedRoleARN != null) {
        entries["ServiceLinkedRoleARN"] = input.ServiceLinkedRoleARN;
    }
    if (input.MaxInstanceLifetime != null) {
        entries["MaxInstanceLifetime"] = input.MaxInstanceLifetime;
    }
    if (input.CapacityRebalance != null) {
        entries["CapacityRebalance"] = input.CapacityRebalance;
    }
    if (input.Context != null) {
        entries["Context"] = input.Context;
    }
    if (input.DesiredCapacityType != null) {
        entries["DesiredCapacityType"] = input.DesiredCapacityType;
    }
    if (input.DefaultInstanceWarmup != null) {
        entries["DefaultInstanceWarmup"] = input.DefaultInstanceWarmup;
    }
    return entries;
};
const se_Values = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VCpuCountRequest = (input, context) => {
    const entries = {};
    if (input.Min != null) {
        entries["Min"] = input.Min;
    }
    if (input.Max != null) {
        entries["Max"] = input.Max;
    }
    return entries;
};
const de_AcceleratorCountRequest = (output, context) => {
    const contents = {};
    if (output["Min"] !== undefined) {
        contents.Min = __strictParseInt32(output["Min"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = __strictParseInt32(output["Max"]);
    }
    return contents;
};
const de_AcceleratorManufacturers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AcceleratorNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AcceleratorTotalMemoryMiBRequest = (output, context) => {
    const contents = {};
    if (output["Min"] !== undefined) {
        contents.Min = __strictParseInt32(output["Min"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = __strictParseInt32(output["Max"]);
    }
    return contents;
};
const de_AcceleratorTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ActiveInstanceRefreshNotFoundFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_Activities = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Activity(entry, context);
    });
};
const de_ActivitiesType = (output, context) => {
    const contents = {};
    if (output.Activities === "") {
        contents.Activities = [];
    }
    else if (output["Activities"] !== undefined && output["Activities"]["member"] !== undefined) {
        contents.Activities = de_Activities(__getArrayIfSingleItem(output["Activities"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_Activity = (output, context) => {
    const contents = {};
    if (output["ActivityId"] !== undefined) {
        contents.ActivityId = __expectString(output["ActivityId"]);
    }
    if (output["AutoScalingGroupName"] !== undefined) {
        contents.AutoScalingGroupName = __expectString(output["AutoScalingGroupName"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = __expectString(output["Description"]);
    }
    if (output["Cause"] !== undefined) {
        contents.Cause = __expectString(output["Cause"]);
    }
    if (output["StartTime"] !== undefined) {
        contents.StartTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["StartTime"]));
    }
    if (output["EndTime"] !== undefined) {
        contents.EndTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["EndTime"]));
    }
    if (output["StatusCode"] !== undefined) {
        contents.StatusCode = __expectString(output["StatusCode"]);
    }
    if (output["StatusMessage"] !== undefined) {
        contents.StatusMessage = __expectString(output["StatusMessage"]);
    }
    if (output["Progress"] !== undefined) {
        contents.Progress = __strictParseInt32(output["Progress"]);
    }
    if (output["Details"] !== undefined) {
        contents.Details = __expectString(output["Details"]);
    }
    if (output["AutoScalingGroupState"] !== undefined) {
        contents.AutoScalingGroupState = __expectString(output["AutoScalingGroupState"]);
    }
    if (output["AutoScalingGroupARN"] !== undefined) {
        contents.AutoScalingGroupARN = __expectString(output["AutoScalingGroupARN"]);
    }
    return contents;
};
const de_ActivityType = (output, context) => {
    const contents = {};
    if (output["Activity"] !== undefined) {
        contents.Activity = de_Activity(output["Activity"], context);
    }
    return contents;
};
const de_AdjustmentType = (output, context) => {
    const contents = {};
    if (output["AdjustmentType"] !== undefined) {
        contents.AdjustmentType = __expectString(output["AdjustmentType"]);
    }
    return contents;
};
const de_AdjustmentTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdjustmentType(entry, context);
    });
};
const de_Alarm = (output, context) => {
    const contents = {};
    if (output["AlarmName"] !== undefined) {
        contents.AlarmName = __expectString(output["AlarmName"]);
    }
    if (output["AlarmARN"] !== undefined) {
        contents.AlarmARN = __expectString(output["AlarmARN"]);
    }
    return contents;
};
const de_Alarms = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Alarm(entry, context);
    });
};
const de_AllowedInstanceTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_AttachLoadBalancersResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_AttachLoadBalancerTargetGroupsResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_AttachTrafficSourcesResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_AutoScalingGroup = (output, context) => {
    const contents = {};
    if (output["AutoScalingGroupName"] !== undefined) {
        contents.AutoScalingGroupName = __expectString(output["AutoScalingGroupName"]);
    }
    if (output["AutoScalingGroupARN"] !== undefined) {
        contents.AutoScalingGroupARN = __expectString(output["AutoScalingGroupARN"]);
    }
    if (output["LaunchConfigurationName"] !== undefined) {
        contents.LaunchConfigurationName = __expectString(output["LaunchConfigurationName"]);
    }
    if (output["LaunchTemplate"] !== undefined) {
        contents.LaunchTemplate = de_LaunchTemplateSpecification(output["LaunchTemplate"], context);
    }
    if (output["MixedInstancesPolicy"] !== undefined) {
        contents.MixedInstancesPolicy = de_MixedInstancesPolicy(output["MixedInstancesPolicy"], context);
    }
    if (output["MinSize"] !== undefined) {
        contents.MinSize = __strictParseInt32(output["MinSize"]);
    }
    if (output["MaxSize"] !== undefined) {
        contents.MaxSize = __strictParseInt32(output["MaxSize"]);
    }
    if (output["DesiredCapacity"] !== undefined) {
        contents.DesiredCapacity = __strictParseInt32(output["DesiredCapacity"]);
    }
    if (output["PredictedCapacity"] !== undefined) {
        contents.PredictedCapacity = __strictParseInt32(output["PredictedCapacity"]);
    }
    if (output["DefaultCooldown"] !== undefined) {
        contents.DefaultCooldown = __strictParseInt32(output["DefaultCooldown"]);
    }
    if (output.AvailabilityZones === "") {
        contents.AvailabilityZones = [];
    }
    else if (output["AvailabilityZones"] !== undefined && output["AvailabilityZones"]["member"] !== undefined) {
        contents.AvailabilityZones = de_AvailabilityZones(__getArrayIfSingleItem(output["AvailabilityZones"]["member"]), context);
    }
    if (output.LoadBalancerNames === "") {
        contents.LoadBalancerNames = [];
    }
    else if (output["LoadBalancerNames"] !== undefined && output["LoadBalancerNames"]["member"] !== undefined) {
        contents.LoadBalancerNames = de_LoadBalancerNames(__getArrayIfSingleItem(output["LoadBalancerNames"]["member"]), context);
    }
    if (output.TargetGroupARNs === "") {
        contents.TargetGroupARNs = [];
    }
    else if (output["TargetGroupARNs"] !== undefined && output["TargetGroupARNs"]["member"] !== undefined) {
        contents.TargetGroupARNs = de_TargetGroupARNs(__getArrayIfSingleItem(output["TargetGroupARNs"]["member"]), context);
    }
    if (output["HealthCheckType"] !== undefined) {
        contents.HealthCheckType = __expectString(output["HealthCheckType"]);
    }
    if (output["HealthCheckGracePeriod"] !== undefined) {
        contents.HealthCheckGracePeriod = __strictParseInt32(output["HealthCheckGracePeriod"]);
    }
    if (output.Instances === "") {
        contents.Instances = [];
    }
    else if (output["Instances"] !== undefined && output["Instances"]["member"] !== undefined) {
        contents.Instances = de_Instances(__getArrayIfSingleItem(output["Instances"]["member"]), context);
    }
    if (output["CreatedTime"] !== undefined) {
        contents.CreatedTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreatedTime"]));
    }
    if (output.SuspendedProcesses === "") {
        contents.SuspendedProcesses = [];
    }
    else if (output["SuspendedProcesses"] !== undefined && output["SuspendedProcesses"]["member"] !== undefined) {
        contents.SuspendedProcesses = de_SuspendedProcesses(__getArrayIfSingleItem(output["SuspendedProcesses"]["member"]), context);
    }
    if (output["PlacementGroup"] !== undefined) {
        contents.PlacementGroup = __expectString(output["PlacementGroup"]);
    }
    if (output["VPCZoneIdentifier"] !== undefined) {
        contents.VPCZoneIdentifier = __expectString(output["VPCZoneIdentifier"]);
    }
    if (output.EnabledMetrics === "") {
        contents.EnabledMetrics = [];
    }
    else if (output["EnabledMetrics"] !== undefined && output["EnabledMetrics"]["member"] !== undefined) {
        contents.EnabledMetrics = de_EnabledMetrics(__getArrayIfSingleItem(output["EnabledMetrics"]["member"]), context);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_TagDescriptionList(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output.TerminationPolicies === "") {
        contents.TerminationPolicies = [];
    }
    else if (output["TerminationPolicies"] !== undefined && output["TerminationPolicies"]["member"] !== undefined) {
        contents.TerminationPolicies = de_TerminationPolicies(__getArrayIfSingleItem(output["TerminationPolicies"]["member"]), context);
    }
    if (output["NewInstancesProtectedFromScaleIn"] !== undefined) {
        contents.NewInstancesProtectedFromScaleIn = __parseBoolean(output["NewInstancesProtectedFromScaleIn"]);
    }
    if (output["ServiceLinkedRoleARN"] !== undefined) {
        contents.ServiceLinkedRoleARN = __expectString(output["ServiceLinkedRoleARN"]);
    }
    if (output["MaxInstanceLifetime"] !== undefined) {
        contents.MaxInstanceLifetime = __strictParseInt32(output["MaxInstanceLifetime"]);
    }
    if (output["CapacityRebalance"] !== undefined) {
        contents.CapacityRebalance = __parseBoolean(output["CapacityRebalance"]);
    }
    if (output["WarmPoolConfiguration"] !== undefined) {
        contents.WarmPoolConfiguration = de_WarmPoolConfiguration(output["WarmPoolConfiguration"], context);
    }
    if (output["WarmPoolSize"] !== undefined) {
        contents.WarmPoolSize = __strictParseInt32(output["WarmPoolSize"]);
    }
    if (output["Context"] !== undefined) {
        contents.Context = __expectString(output["Context"]);
    }
    if (output["DesiredCapacityType"] !== undefined) {
        contents.DesiredCapacityType = __expectString(output["DesiredCapacityType"]);
    }
    if (output["DefaultInstanceWarmup"] !== undefined) {
        contents.DefaultInstanceWarmup = __strictParseInt32(output["DefaultInstanceWarmup"]);
    }
    if (output.TrafficSources === "") {
        contents.TrafficSources = [];
    }
    else if (output["TrafficSources"] !== undefined && output["TrafficSources"]["member"] !== undefined) {
        contents.TrafficSources = de_TrafficSources(__getArrayIfSingleItem(output["TrafficSources"]["member"]), context);
    }
    return contents;
};
const de_AutoScalingGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutoScalingGroup(entry, context);
    });
};
const de_AutoScalingGroupsType = (output, context) => {
    const contents = {};
    if (output.AutoScalingGroups === "") {
        contents.AutoScalingGroups = [];
    }
    else if (output["AutoScalingGroups"] !== undefined && output["AutoScalingGroups"]["member"] !== undefined) {
        contents.AutoScalingGroups = de_AutoScalingGroups(__getArrayIfSingleItem(output["AutoScalingGroups"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_AutoScalingInstanceDetails = (output, context) => {
    const contents = {};
    if (output["InstanceId"] !== undefined) {
        contents.InstanceId = __expectString(output["InstanceId"]);
    }
    if (output["InstanceType"] !== undefined) {
        contents.InstanceType = __expectString(output["InstanceType"]);
    }
    if (output["AutoScalingGroupName"] !== undefined) {
        contents.AutoScalingGroupName = __expectString(output["AutoScalingGroupName"]);
    }
    if (output["AvailabilityZone"] !== undefined) {
        contents.AvailabilityZone = __expectString(output["AvailabilityZone"]);
    }
    if (output["LifecycleState"] !== undefined) {
        contents.LifecycleState = __expectString(output["LifecycleState"]);
    }
    if (output["HealthStatus"] !== undefined) {
        contents.HealthStatus = __expectString(output["HealthStatus"]);
    }
    if (output["LaunchConfigurationName"] !== undefined) {
        contents.LaunchConfigurationName = __expectString(output["LaunchConfigurationName"]);
    }
    if (output["LaunchTemplate"] !== undefined) {
        contents.LaunchTemplate = de_LaunchTemplateSpecification(output["LaunchTemplate"], context);
    }
    if (output["ProtectedFromScaleIn"] !== undefined) {
        contents.ProtectedFromScaleIn = __parseBoolean(output["ProtectedFromScaleIn"]);
    }
    if (output["WeightedCapacity"] !== undefined) {
        contents.WeightedCapacity = __expectString(output["WeightedCapacity"]);
    }
    return contents;
};
const de_AutoScalingInstances = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AutoScalingInstanceDetails(entry, context);
    });
};
const de_AutoScalingInstancesType = (output, context) => {
    const contents = {};
    if (output.AutoScalingInstances === "") {
        contents.AutoScalingInstances = [];
    }
    else if (output["AutoScalingInstances"] !== undefined && output["AutoScalingInstances"]["member"] !== undefined) {
        contents.AutoScalingInstances = de_AutoScalingInstances(__getArrayIfSingleItem(output["AutoScalingInstances"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_AutoScalingNotificationTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AvailabilityZones = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_BaselineEbsBandwidthMbpsRequest = (output, context) => {
    const contents = {};
    if (output["Min"] !== undefined) {
        contents.Min = __strictParseInt32(output["Min"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = __strictParseInt32(output["Max"]);
    }
    return contents;
};
const de_BatchDeleteScheduledActionAnswer = (output, context) => {
    const contents = {};
    if (output.FailedScheduledActions === "") {
        contents.FailedScheduledActions = [];
    }
    else if (output["FailedScheduledActions"] !== undefined &&
        output["FailedScheduledActions"]["member"] !== undefined) {
        contents.FailedScheduledActions = de_FailedScheduledUpdateGroupActionRequests(__getArrayIfSingleItem(output["FailedScheduledActions"]["member"]), context);
    }
    return contents;
};
const de_BatchPutScheduledUpdateGroupActionAnswer = (output, context) => {
    const contents = {};
    if (output.FailedScheduledUpdateGroupActions === "") {
        contents.FailedScheduledUpdateGroupActions = [];
    }
    else if (output["FailedScheduledUpdateGroupActions"] !== undefined &&
        output["FailedScheduledUpdateGroupActions"]["member"] !== undefined) {
        contents.FailedScheduledUpdateGroupActions = de_FailedScheduledUpdateGroupActionRequests(__getArrayIfSingleItem(output["FailedScheduledUpdateGroupActions"]["member"]), context);
    }
    return contents;
};
const de_BlockDeviceMapping = (output, context) => {
    const contents = {};
    if (output["VirtualName"] !== undefined) {
        contents.VirtualName = __expectString(output["VirtualName"]);
    }
    if (output["DeviceName"] !== undefined) {
        contents.DeviceName = __expectString(output["DeviceName"]);
    }
    if (output["Ebs"] !== undefined) {
        contents.Ebs = de_Ebs(output["Ebs"], context);
    }
    if (output["NoDevice"] !== undefined) {
        contents.NoDevice = __parseBoolean(output["NoDevice"]);
    }
    return contents;
};
const de_BlockDeviceMappings = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BlockDeviceMapping(entry, context);
    });
};
const de_CancelInstanceRefreshAnswer = (output, context) => {
    const contents = {};
    if (output["InstanceRefreshId"] !== undefined) {
        contents.InstanceRefreshId = __expectString(output["InstanceRefreshId"]);
    }
    return contents;
};
const de_CapacityForecast = (output, context) => {
    const contents = {};
    if (output.Timestamps === "") {
        contents.Timestamps = [];
    }
    else if (output["Timestamps"] !== undefined && output["Timestamps"]["member"] !== undefined) {
        contents.Timestamps = de_PredictiveScalingForecastTimestamps(__getArrayIfSingleItem(output["Timestamps"]["member"]), context);
    }
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_PredictiveScalingForecastValues(__getArrayIfSingleItem(output["Values"]["member"]), context);
    }
    return contents;
};
const de_CheckpointPercentages = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseInt32(entry);
    });
};
const de_ClassicLinkVPCSecurityGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CompleteLifecycleActionAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_CpuManufacturers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CustomizedMetricSpecification = (output, context) => {
    const contents = {};
    if (output["MetricName"] !== undefined) {
        contents.MetricName = __expectString(output["MetricName"]);
    }
    if (output["Namespace"] !== undefined) {
        contents.Namespace = __expectString(output["Namespace"]);
    }
    if (output.Dimensions === "") {
        contents.Dimensions = [];
    }
    else if (output["Dimensions"] !== undefined && output["Dimensions"]["member"] !== undefined) {
        contents.Dimensions = de_MetricDimensions(__getArrayIfSingleItem(output["Dimensions"]["member"]), context);
    }
    if (output["Statistic"] !== undefined) {
        contents.Statistic = __expectString(output["Statistic"]);
    }
    if (output["Unit"] !== undefined) {
        contents.Unit = __expectString(output["Unit"]);
    }
    if (output.Metrics === "") {
        contents.Metrics = [];
    }
    else if (output["Metrics"] !== undefined && output["Metrics"]["member"] !== undefined) {
        contents.Metrics = de_TargetTrackingMetricDataQueries(__getArrayIfSingleItem(output["Metrics"]["member"]), context);
    }
    return contents;
};
const de_DeleteLifecycleHookAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteWarmPoolAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_DescribeAccountLimitsAnswer = (output, context) => {
    const contents = {};
    if (output["MaxNumberOfAutoScalingGroups"] !== undefined) {
        contents.MaxNumberOfAutoScalingGroups = __strictParseInt32(output["MaxNumberOfAutoScalingGroups"]);
    }
    if (output["MaxNumberOfLaunchConfigurations"] !== undefined) {
        contents.MaxNumberOfLaunchConfigurations = __strictParseInt32(output["MaxNumberOfLaunchConfigurations"]);
    }
    if (output["NumberOfAutoScalingGroups"] !== undefined) {
        contents.NumberOfAutoScalingGroups = __strictParseInt32(output["NumberOfAutoScalingGroups"]);
    }
    if (output["NumberOfLaunchConfigurations"] !== undefined) {
        contents.NumberOfLaunchConfigurations = __strictParseInt32(output["NumberOfLaunchConfigurations"]);
    }
    return contents;
};
const de_DescribeAdjustmentTypesAnswer = (output, context) => {
    const contents = {};
    if (output.AdjustmentTypes === "") {
        contents.AdjustmentTypes = [];
    }
    else if (output["AdjustmentTypes"] !== undefined && output["AdjustmentTypes"]["member"] !== undefined) {
        contents.AdjustmentTypes = de_AdjustmentTypes(__getArrayIfSingleItem(output["AdjustmentTypes"]["member"]), context);
    }
    return contents;
};
const de_DescribeAutoScalingNotificationTypesAnswer = (output, context) => {
    const contents = {};
    if (output.AutoScalingNotificationTypes === "") {
        contents.AutoScalingNotificationTypes = [];
    }
    else if (output["AutoScalingNotificationTypes"] !== undefined &&
        output["AutoScalingNotificationTypes"]["member"] !== undefined) {
        contents.AutoScalingNotificationTypes = de_AutoScalingNotificationTypes(__getArrayIfSingleItem(output["AutoScalingNotificationTypes"]["member"]), context);
    }
    return contents;
};
const de_DescribeInstanceRefreshesAnswer = (output, context) => {
    const contents = {};
    if (output.InstanceRefreshes === "") {
        contents.InstanceRefreshes = [];
    }
    else if (output["InstanceRefreshes"] !== undefined && output["InstanceRefreshes"]["member"] !== undefined) {
        contents.InstanceRefreshes = de_InstanceRefreshes(__getArrayIfSingleItem(output["InstanceRefreshes"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_DescribeLifecycleHooksAnswer = (output, context) => {
    const contents = {};
    if (output.LifecycleHooks === "") {
        contents.LifecycleHooks = [];
    }
    else if (output["LifecycleHooks"] !== undefined && output["LifecycleHooks"]["member"] !== undefined) {
        contents.LifecycleHooks = de_LifecycleHooks(__getArrayIfSingleItem(output["LifecycleHooks"]["member"]), context);
    }
    return contents;
};
const de_DescribeLifecycleHookTypesAnswer = (output, context) => {
    const contents = {};
    if (output.LifecycleHookTypes === "") {
        contents.LifecycleHookTypes = [];
    }
    else if (output["LifecycleHookTypes"] !== undefined && output["LifecycleHookTypes"]["member"] !== undefined) {
        contents.LifecycleHookTypes = de_AutoScalingNotificationTypes(__getArrayIfSingleItem(output["LifecycleHookTypes"]["member"]), context);
    }
    return contents;
};
const de_DescribeLoadBalancersResponse = (output, context) => {
    const contents = {};
    if (output.LoadBalancers === "") {
        contents.LoadBalancers = [];
    }
    else if (output["LoadBalancers"] !== undefined && output["LoadBalancers"]["member"] !== undefined) {
        contents.LoadBalancers = de_LoadBalancerStates(__getArrayIfSingleItem(output["LoadBalancers"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_DescribeLoadBalancerTargetGroupsResponse = (output, context) => {
    const contents = {};
    if (output.LoadBalancerTargetGroups === "") {
        contents.LoadBalancerTargetGroups = [];
    }
    else if (output["LoadBalancerTargetGroups"] !== undefined &&
        output["LoadBalancerTargetGroups"]["member"] !== undefined) {
        contents.LoadBalancerTargetGroups = de_LoadBalancerTargetGroupStates(__getArrayIfSingleItem(output["LoadBalancerTargetGroups"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_DescribeMetricCollectionTypesAnswer = (output, context) => {
    const contents = {};
    if (output.Metrics === "") {
        contents.Metrics = [];
    }
    else if (output["Metrics"] !== undefined && output["Metrics"]["member"] !== undefined) {
        contents.Metrics = de_MetricCollectionTypes(__getArrayIfSingleItem(output["Metrics"]["member"]), context);
    }
    if (output.Granularities === "") {
        contents.Granularities = [];
    }
    else if (output["Granularities"] !== undefined && output["Granularities"]["member"] !== undefined) {
        contents.Granularities = de_MetricGranularityTypes(__getArrayIfSingleItem(output["Granularities"]["member"]), context);
    }
    return contents;
};
const de_DescribeNotificationConfigurationsAnswer = (output, context) => {
    const contents = {};
    if (output.NotificationConfigurations === "") {
        contents.NotificationConfigurations = [];
    }
    else if (output["NotificationConfigurations"] !== undefined &&
        output["NotificationConfigurations"]["member"] !== undefined) {
        contents.NotificationConfigurations = de_NotificationConfigurations(__getArrayIfSingleItem(output["NotificationConfigurations"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_DescribeTerminationPolicyTypesAnswer = (output, context) => {
    const contents = {};
    if (output.TerminationPolicyTypes === "") {
        contents.TerminationPolicyTypes = [];
    }
    else if (output["TerminationPolicyTypes"] !== undefined &&
        output["TerminationPolicyTypes"]["member"] !== undefined) {
        contents.TerminationPolicyTypes = de_TerminationPolicies(__getArrayIfSingleItem(output["TerminationPolicyTypes"]["member"]), context);
    }
    return contents;
};
const de_DescribeTrafficSourcesResponse = (output, context) => {
    const contents = {};
    if (output.TrafficSources === "") {
        contents.TrafficSources = [];
    }
    else if (output["TrafficSources"] !== undefined && output["TrafficSources"]["member"] !== undefined) {
        contents.TrafficSources = de_TrafficSourceStates(__getArrayIfSingleItem(output["TrafficSources"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_DescribeWarmPoolAnswer = (output, context) => {
    const contents = {};
    if (output["WarmPoolConfiguration"] !== undefined) {
        contents.WarmPoolConfiguration = de_WarmPoolConfiguration(output["WarmPoolConfiguration"], context);
    }
    if (output.Instances === "") {
        contents.Instances = [];
    }
    else if (output["Instances"] !== undefined && output["Instances"]["member"] !== undefined) {
        contents.Instances = de_Instances(__getArrayIfSingleItem(output["Instances"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_DesiredConfiguration = (output, context) => {
    const contents = {};
    if (output["LaunchTemplate"] !== undefined) {
        contents.LaunchTemplate = de_LaunchTemplateSpecification(output["LaunchTemplate"], context);
    }
    if (output["MixedInstancesPolicy"] !== undefined) {
        contents.MixedInstancesPolicy = de_MixedInstancesPolicy(output["MixedInstancesPolicy"], context);
    }
    return contents;
};
const de_DetachInstancesAnswer = (output, context) => {
    const contents = {};
    if (output.Activities === "") {
        contents.Activities = [];
    }
    else if (output["Activities"] !== undefined && output["Activities"]["member"] !== undefined) {
        contents.Activities = de_Activities(__getArrayIfSingleItem(output["Activities"]["member"]), context);
    }
    return contents;
};
const de_DetachLoadBalancersResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_DetachLoadBalancerTargetGroupsResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_DetachTrafficSourcesResultType = (output, context) => {
    const contents = {};
    return contents;
};
const de_Ebs = (output, context) => {
    const contents = {};
    if (output["SnapshotId"] !== undefined) {
        contents.SnapshotId = __expectString(output["SnapshotId"]);
    }
    if (output["VolumeSize"] !== undefined) {
        contents.VolumeSize = __strictParseInt32(output["VolumeSize"]);
    }
    if (output["VolumeType"] !== undefined) {
        contents.VolumeType = __expectString(output["VolumeType"]);
    }
    if (output["DeleteOnTermination"] !== undefined) {
        contents.DeleteOnTermination = __parseBoolean(output["DeleteOnTermination"]);
    }
    if (output["Iops"] !== undefined) {
        contents.Iops = __strictParseInt32(output["Iops"]);
    }
    if (output["Encrypted"] !== undefined) {
        contents.Encrypted = __parseBoolean(output["Encrypted"]);
    }
    if (output["Throughput"] !== undefined) {
        contents.Throughput = __strictParseInt32(output["Throughput"]);
    }
    return contents;
};
const de_EnabledMetric = (output, context) => {
    const contents = {};
    if (output["Metric"] !== undefined) {
        contents.Metric = __expectString(output["Metric"]);
    }
    if (output["Granularity"] !== undefined) {
        contents.Granularity = __expectString(output["Granularity"]);
    }
    return contents;
};
const de_EnabledMetrics = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EnabledMetric(entry, context);
    });
};
const de_EnterStandbyAnswer = (output, context) => {
    const contents = {};
    if (output.Activities === "") {
        contents.Activities = [];
    }
    else if (output["Activities"] !== undefined && output["Activities"]["member"] !== undefined) {
        contents.Activities = de_Activities(__getArrayIfSingleItem(output["Activities"]["member"]), context);
    }
    return contents;
};
const de_ExcludedInstanceTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ExitStandbyAnswer = (output, context) => {
    const contents = {};
    if (output.Activities === "") {
        contents.Activities = [];
    }
    else if (output["Activities"] !== undefined && output["Activities"]["member"] !== undefined) {
        contents.Activities = de_Activities(__getArrayIfSingleItem(output["Activities"]["member"]), context);
    }
    return contents;
};
const de_FailedScheduledUpdateGroupActionRequest = (output, context) => {
    const contents = {};
    if (output["ScheduledActionName"] !== undefined) {
        contents.ScheduledActionName = __expectString(output["ScheduledActionName"]);
    }
    if (output["ErrorCode"] !== undefined) {
        contents.ErrorCode = __expectString(output["ErrorCode"]);
    }
    if (output["ErrorMessage"] !== undefined) {
        contents.ErrorMessage = __expectString(output["ErrorMessage"]);
    }
    return contents;
};
const de_FailedScheduledUpdateGroupActionRequests = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FailedScheduledUpdateGroupActionRequest(entry, context);
    });
};
const de_GetPredictiveScalingForecastAnswer = (output, context) => {
    const contents = {};
    if (output.LoadForecast === "") {
        contents.LoadForecast = [];
    }
    else if (output["LoadForecast"] !== undefined && output["LoadForecast"]["member"] !== undefined) {
        contents.LoadForecast = de_LoadForecasts(__getArrayIfSingleItem(output["LoadForecast"]["member"]), context);
    }
    if (output["CapacityForecast"] !== undefined) {
        contents.CapacityForecast = de_CapacityForecast(output["CapacityForecast"], context);
    }
    if (output["UpdateTime"] !== undefined) {
        contents.UpdateTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["UpdateTime"]));
    }
    return contents;
};
const de_Instance = (output, context) => {
    const contents = {};
    if (output["InstanceId"] !== undefined) {
        contents.InstanceId = __expectString(output["InstanceId"]);
    }
    if (output["InstanceType"] !== undefined) {
        contents.InstanceType = __expectString(output["InstanceType"]);
    }
    if (output["AvailabilityZone"] !== undefined) {
        contents.AvailabilityZone = __expectString(output["AvailabilityZone"]);
    }
    if (output["LifecycleState"] !== undefined) {
        contents.LifecycleState = __expectString(output["LifecycleState"]);
    }
    if (output["HealthStatus"] !== undefined) {
        contents.HealthStatus = __expectString(output["HealthStatus"]);
    }
    if (output["LaunchConfigurationName"] !== undefined) {
        contents.LaunchConfigurationName = __expectString(output["LaunchConfigurationName"]);
    }
    if (output["LaunchTemplate"] !== undefined) {
        contents.LaunchTemplate = de_LaunchTemplateSpecification(output["LaunchTemplate"], context);
    }
    if (output["ProtectedFromScaleIn"] !== undefined) {
        contents.ProtectedFromScaleIn = __parseBoolean(output["ProtectedFromScaleIn"]);
    }
    if (output["WeightedCapacity"] !== undefined) {
        contents.WeightedCapacity = __expectString(output["WeightedCapacity"]);
    }
    return contents;
};
const de_InstanceGenerations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceMetadataOptions = (output, context) => {
    const contents = {};
    if (output["HttpTokens"] !== undefined) {
        contents.HttpTokens = __expectString(output["HttpTokens"]);
    }
    if (output["HttpPutResponseHopLimit"] !== undefined) {
        contents.HttpPutResponseHopLimit = __strictParseInt32(output["HttpPutResponseHopLimit"]);
    }
    if (output["HttpEndpoint"] !== undefined) {
        contents.HttpEndpoint = __expectString(output["HttpEndpoint"]);
    }
    return contents;
};
const de_InstanceMonitoring = (output, context) => {
    const contents = {};
    if (output["Enabled"] !== undefined) {
        contents.Enabled = __parseBoolean(output["Enabled"]);
    }
    return contents;
};
const de_InstanceRefresh = (output, context) => {
    const contents = {};
    if (output["InstanceRefreshId"] !== undefined) {
        contents.InstanceRefreshId = __expectString(output["InstanceRefreshId"]);
    }
    if (output["AutoScalingGroupName"] !== undefined) {
        contents.AutoScalingGroupName = __expectString(output["AutoScalingGroupName"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["StatusReason"] !== undefined) {
        contents.StatusReason = __expectString(output["StatusReason"]);
    }
    if (output["StartTime"] !== undefined) {
        contents.StartTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["StartTime"]));
    }
    if (output["EndTime"] !== undefined) {
        contents.EndTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["EndTime"]));
    }
    if (output["PercentageComplete"] !== undefined) {
        contents.PercentageComplete = __strictParseInt32(output["PercentageComplete"]);
    }
    if (output["InstancesToUpdate"] !== undefined) {
        contents.InstancesToUpdate = __strictParseInt32(output["InstancesToUpdate"]);
    }
    if (output["ProgressDetails"] !== undefined) {
        contents.ProgressDetails = de_InstanceRefreshProgressDetails(output["ProgressDetails"], context);
    }
    if (output["Preferences"] !== undefined) {
        contents.Preferences = de_RefreshPreferences(output["Preferences"], context);
    }
    if (output["DesiredConfiguration"] !== undefined) {
        contents.DesiredConfiguration = de_DesiredConfiguration(output["DesiredConfiguration"], context);
    }
    if (output["RollbackDetails"] !== undefined) {
        contents.RollbackDetails = de_RollbackDetails(output["RollbackDetails"], context);
    }
    return contents;
};
const de_InstanceRefreshes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceRefresh(entry, context);
    });
};
const de_InstanceRefreshInProgressFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_InstanceRefreshLivePoolProgress = (output, context) => {
    const contents = {};
    if (output["PercentageComplete"] !== undefined) {
        contents.PercentageComplete = __strictParseInt32(output["PercentageComplete"]);
    }
    if (output["InstancesToUpdate"] !== undefined) {
        contents.InstancesToUpdate = __strictParseInt32(output["InstancesToUpdate"]);
    }
    return contents;
};
const de_InstanceRefreshProgressDetails = (output, context) => {
    const contents = {};
    if (output["LivePoolProgress"] !== undefined) {
        contents.LivePoolProgress = de_InstanceRefreshLivePoolProgress(output["LivePoolProgress"], context);
    }
    if (output["WarmPoolProgress"] !== undefined) {
        contents.WarmPoolProgress = de_InstanceRefreshWarmPoolProgress(output["WarmPoolProgress"], context);
    }
    return contents;
};
const de_InstanceRefreshWarmPoolProgress = (output, context) => {
    const contents = {};
    if (output["PercentageComplete"] !== undefined) {
        contents.PercentageComplete = __strictParseInt32(output["PercentageComplete"]);
    }
    if (output["InstancesToUpdate"] !== undefined) {
        contents.InstancesToUpdate = __strictParseInt32(output["InstancesToUpdate"]);
    }
    return contents;
};
const de_InstanceRequirements = (output, context) => {
    const contents = {};
    if (output["VCpuCount"] !== undefined) {
        contents.VCpuCount = de_VCpuCountRequest(output["VCpuCount"], context);
    }
    if (output["MemoryMiB"] !== undefined) {
        contents.MemoryMiB = de_MemoryMiBRequest(output["MemoryMiB"], context);
    }
    if (output.CpuManufacturers === "") {
        contents.CpuManufacturers = [];
    }
    else if (output["CpuManufacturers"] !== undefined && output["CpuManufacturers"]["member"] !== undefined) {
        contents.CpuManufacturers = de_CpuManufacturers(__getArrayIfSingleItem(output["CpuManufacturers"]["member"]), context);
    }
    if (output["MemoryGiBPerVCpu"] !== undefined) {
        contents.MemoryGiBPerVCpu = de_MemoryGiBPerVCpuRequest(output["MemoryGiBPerVCpu"], context);
    }
    if (output.ExcludedInstanceTypes === "") {
        contents.ExcludedInstanceTypes = [];
    }
    else if (output["ExcludedInstanceTypes"] !== undefined && output["ExcludedInstanceTypes"]["member"] !== undefined) {
        contents.ExcludedInstanceTypes = de_ExcludedInstanceTypes(__getArrayIfSingleItem(output["ExcludedInstanceTypes"]["member"]), context);
    }
    if (output.InstanceGenerations === "") {
        contents.InstanceGenerations = [];
    }
    else if (output["InstanceGenerations"] !== undefined && output["InstanceGenerations"]["member"] !== undefined) {
        contents.InstanceGenerations = de_InstanceGenerations(__getArrayIfSingleItem(output["InstanceGenerations"]["member"]), context);
    }
    if (output["SpotMaxPricePercentageOverLowestPrice"] !== undefined) {
        contents.SpotMaxPricePercentageOverLowestPrice = __strictParseInt32(output["SpotMaxPricePercentageOverLowestPrice"]);
    }
    if (output["OnDemandMaxPricePercentageOverLowestPrice"] !== undefined) {
        contents.OnDemandMaxPricePercentageOverLowestPrice = __strictParseInt32(output["OnDemandMaxPricePercentageOverLowestPrice"]);
    }
    if (output["BareMetal"] !== undefined) {
        contents.BareMetal = __expectString(output["BareMetal"]);
    }
    if (output["BurstablePerformance"] !== undefined) {
        contents.BurstablePerformance = __expectString(output["BurstablePerformance"]);
    }
    if (output["RequireHibernateSupport"] !== undefined) {
        contents.RequireHibernateSupport = __parseBoolean(output["RequireHibernateSupport"]);
    }
    if (output["NetworkInterfaceCount"] !== undefined) {
        contents.NetworkInterfaceCount = de_NetworkInterfaceCountRequest(output["NetworkInterfaceCount"], context);
    }
    if (output["LocalStorage"] !== undefined) {
        contents.LocalStorage = __expectString(output["LocalStorage"]);
    }
    if (output.LocalStorageTypes === "") {
        contents.LocalStorageTypes = [];
    }
    else if (output["LocalStorageTypes"] !== undefined && output["LocalStorageTypes"]["member"] !== undefined) {
        contents.LocalStorageTypes = de_LocalStorageTypes(__getArrayIfSingleItem(output["LocalStorageTypes"]["member"]), context);
    }
    if (output["TotalLocalStorageGB"] !== undefined) {
        contents.TotalLocalStorageGB = de_TotalLocalStorageGBRequest(output["TotalLocalStorageGB"], context);
    }
    if (output["BaselineEbsBandwidthMbps"] !== undefined) {
        contents.BaselineEbsBandwidthMbps = de_BaselineEbsBandwidthMbpsRequest(output["BaselineEbsBandwidthMbps"], context);
    }
    if (output.AcceleratorTypes === "") {
        contents.AcceleratorTypes = [];
    }
    else if (output["AcceleratorTypes"] !== undefined && output["AcceleratorTypes"]["member"] !== undefined) {
        contents.AcceleratorTypes = de_AcceleratorTypes(__getArrayIfSingleItem(output["AcceleratorTypes"]["member"]), context);
    }
    if (output["AcceleratorCount"] !== undefined) {
        contents.AcceleratorCount = de_AcceleratorCountRequest(output["AcceleratorCount"], context);
    }
    if (output.AcceleratorManufacturers === "") {
        contents.AcceleratorManufacturers = [];
    }
    else if (output["AcceleratorManufacturers"] !== undefined &&
        output["AcceleratorManufacturers"]["member"] !== undefined) {
        contents.AcceleratorManufacturers = de_AcceleratorManufacturers(__getArrayIfSingleItem(output["AcceleratorManufacturers"]["member"]), context);
    }
    if (output.AcceleratorNames === "") {
        contents.AcceleratorNames = [];
    }
    else if (output["AcceleratorNames"] !== undefined && output["AcceleratorNames"]["member"] !== undefined) {
        contents.AcceleratorNames = de_AcceleratorNames(__getArrayIfSingleItem(output["AcceleratorNames"]["member"]), context);
    }
    if (output["AcceleratorTotalMemoryMiB"] !== undefined) {
        contents.AcceleratorTotalMemoryMiB = de_AcceleratorTotalMemoryMiBRequest(output["AcceleratorTotalMemoryMiB"], context);
    }
    if (output["NetworkBandwidthGbps"] !== undefined) {
        contents.NetworkBandwidthGbps = de_NetworkBandwidthGbpsRequest(output["NetworkBandwidthGbps"], context);
    }
    if (output.AllowedInstanceTypes === "") {
        contents.AllowedInstanceTypes = [];
    }
    else if (output["AllowedInstanceTypes"] !== undefined && output["AllowedInstanceTypes"]["member"] !== undefined) {
        contents.AllowedInstanceTypes = de_AllowedInstanceTypes(__getArrayIfSingleItem(output["AllowedInstanceTypes"]["member"]), context);
    }
    return contents;
};
const de_InstanceReusePolicy = (output, context) => {
    const contents = {};
    if (output["ReuseOnScaleIn"] !== undefined) {
        contents.ReuseOnScaleIn = __parseBoolean(output["ReuseOnScaleIn"]);
    }
    return contents;
};
const de_Instances = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Instance(entry, context);
    });
};
const de_InstancesDistribution = (output, context) => {
    const contents = {};
    if (output["OnDemandAllocationStrategy"] !== undefined) {
        contents.OnDemandAllocationStrategy = __expectString(output["OnDemandAllocationStrategy"]);
    }
    if (output["OnDemandBaseCapacity"] !== undefined) {
        contents.OnDemandBaseCapacity = __strictParseInt32(output["OnDemandBaseCapacity"]);
    }
    if (output["OnDemandPercentageAboveBaseCapacity"] !== undefined) {
        contents.OnDemandPercentageAboveBaseCapacity = __strictParseInt32(output["OnDemandPercentageAboveBaseCapacity"]);
    }
    if (output["SpotAllocationStrategy"] !== undefined) {
        contents.SpotAllocationStrategy = __expectString(output["SpotAllocationStrategy"]);
    }
    if (output["SpotInstancePools"] !== undefined) {
        contents.SpotInstancePools = __strictParseInt32(output["SpotInstancePools"]);
    }
    if (output["SpotMaxPrice"] !== undefined) {
        contents.SpotMaxPrice = __expectString(output["SpotMaxPrice"]);
    }
    return contents;
};
const de_InvalidNextToken = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_IrreversibleInstanceRefreshFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_LaunchConfiguration = (output, context) => {
    const contents = {};
    if (output["LaunchConfigurationName"] !== undefined) {
        contents.LaunchConfigurationName = __expectString(output["LaunchConfigurationName"]);
    }
    if (output["LaunchConfigurationARN"] !== undefined) {
        contents.LaunchConfigurationARN = __expectString(output["LaunchConfigurationARN"]);
    }
    if (output["ImageId"] !== undefined) {
        contents.ImageId = __expectString(output["ImageId"]);
    }
    if (output["KeyName"] !== undefined) {
        contents.KeyName = __expectString(output["KeyName"]);
    }
    if (output.SecurityGroups === "") {
        contents.SecurityGroups = [];
    }
    else if (output["SecurityGroups"] !== undefined && output["SecurityGroups"]["member"] !== undefined) {
        contents.SecurityGroups = de_SecurityGroups(__getArrayIfSingleItem(output["SecurityGroups"]["member"]), context);
    }
    if (output["ClassicLinkVPCId"] !== undefined) {
        contents.ClassicLinkVPCId = __expectString(output["ClassicLinkVPCId"]);
    }
    if (output.ClassicLinkVPCSecurityGroups === "") {
        contents.ClassicLinkVPCSecurityGroups = [];
    }
    else if (output["ClassicLinkVPCSecurityGroups"] !== undefined &&
        output["ClassicLinkVPCSecurityGroups"]["member"] !== undefined) {
        contents.ClassicLinkVPCSecurityGroups = de_ClassicLinkVPCSecurityGroups(__getArrayIfSingleItem(output["ClassicLinkVPCSecurityGroups"]["member"]), context);
    }
    if (output["UserData"] !== undefined) {
        contents.UserData = __expectString(output["UserData"]);
    }
    if (output["InstanceType"] !== undefined) {
        contents.InstanceType = __expectString(output["InstanceType"]);
    }
    if (output["KernelId"] !== undefined) {
        contents.KernelId = __expectString(output["KernelId"]);
    }
    if (output["RamdiskId"] !== undefined) {
        contents.RamdiskId = __expectString(output["RamdiskId"]);
    }
    if (output.BlockDeviceMappings === "") {
        contents.BlockDeviceMappings = [];
    }
    else if (output["BlockDeviceMappings"] !== undefined && output["BlockDeviceMappings"]["member"] !== undefined) {
        contents.BlockDeviceMappings = de_BlockDeviceMappings(__getArrayIfSingleItem(output["BlockDeviceMappings"]["member"]), context);
    }
    if (output["InstanceMonitoring"] !== undefined) {
        contents.InstanceMonitoring = de_InstanceMonitoring(output["InstanceMonitoring"], context);
    }
    if (output["SpotPrice"] !== undefined) {
        contents.SpotPrice = __expectString(output["SpotPrice"]);
    }
    if (output["IamInstanceProfile"] !== undefined) {
        contents.IamInstanceProfile = __expectString(output["IamInstanceProfile"]);
    }
    if (output["CreatedTime"] !== undefined) {
        contents.CreatedTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreatedTime"]));
    }
    if (output["EbsOptimized"] !== undefined) {
        contents.EbsOptimized = __parseBoolean(output["EbsOptimized"]);
    }
    if (output["AssociatePublicIpAddress"] !== undefined) {
        contents.AssociatePublicIpAddress = __parseBoolean(output["AssociatePublicIpAddress"]);
    }
    if (output["PlacementTenancy"] !== undefined) {
        contents.PlacementTenancy = __expectString(output["PlacementTenancy"]);
    }
    if (output["MetadataOptions"] !== undefined) {
        contents.MetadataOptions = de_InstanceMetadataOptions(output["MetadataOptions"], context);
    }
    return contents;
};
const de_LaunchConfigurations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchConfiguration(entry, context);
    });
};
const de_LaunchConfigurationsType = (output, context) => {
    const contents = {};
    if (output.LaunchConfigurations === "") {
        contents.LaunchConfigurations = [];
    }
    else if (output["LaunchConfigurations"] !== undefined && output["LaunchConfigurations"]["member"] !== undefined) {
        contents.LaunchConfigurations = de_LaunchConfigurations(__getArrayIfSingleItem(output["LaunchConfigurations"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_LaunchTemplate = (output, context) => {
    const contents = {};
    if (output["LaunchTemplateSpecification"] !== undefined) {
        contents.LaunchTemplateSpecification = de_LaunchTemplateSpecification(output["LaunchTemplateSpecification"], context);
    }
    if (output.Overrides === "") {
        contents.Overrides = [];
    }
    else if (output["Overrides"] !== undefined && output["Overrides"]["member"] !== undefined) {
        contents.Overrides = de_Overrides(__getArrayIfSingleItem(output["Overrides"]["member"]), context);
    }
    return contents;
};
const de_LaunchTemplateOverrides = (output, context) => {
    const contents = {};
    if (output["InstanceType"] !== undefined) {
        contents.InstanceType = __expectString(output["InstanceType"]);
    }
    if (output["WeightedCapacity"] !== undefined) {
        contents.WeightedCapacity = __expectString(output["WeightedCapacity"]);
    }
    if (output["LaunchTemplateSpecification"] !== undefined) {
        contents.LaunchTemplateSpecification = de_LaunchTemplateSpecification(output["LaunchTemplateSpecification"], context);
    }
    if (output["InstanceRequirements"] !== undefined) {
        contents.InstanceRequirements = de_InstanceRequirements(output["InstanceRequirements"], context);
    }
    return contents;
};
const de_LaunchTemplateSpecification = (output, context) => {
    const contents = {};
    if (output["LaunchTemplateId"] !== undefined) {
        contents.LaunchTemplateId = __expectString(output["LaunchTemplateId"]);
    }
    if (output["LaunchTemplateName"] !== undefined) {
        contents.LaunchTemplateName = __expectString(output["LaunchTemplateName"]);
    }
    if (output["Version"] !== undefined) {
        contents.Version = __expectString(output["Version"]);
    }
    return contents;
};
const de_LifecycleHook = (output, context) => {
    const contents = {};
    if (output["LifecycleHookName"] !== undefined) {
        contents.LifecycleHookName = __expectString(output["LifecycleHookName"]);
    }
    if (output["AutoScalingGroupName"] !== undefined) {
        contents.AutoScalingGroupName = __expectString(output["AutoScalingGroupName"]);
    }
    if (output["LifecycleTransition"] !== undefined) {
        contents.LifecycleTransition = __expectString(output["LifecycleTransition"]);
    }
    if (output["NotificationTargetARN"] !== undefined) {
        contents.NotificationTargetARN = __expectString(output["NotificationTargetARN"]);
    }
    if (output["RoleARN"] !== undefined) {
        contents.RoleARN = __expectString(output["RoleARN"]);
    }
    if (output["NotificationMetadata"] !== undefined) {
        contents.NotificationMetadata = __expectString(output["NotificationMetadata"]);
    }
    if (output["HeartbeatTimeout"] !== undefined) {
        contents.HeartbeatTimeout = __strictParseInt32(output["HeartbeatTimeout"]);
    }
    if (output["GlobalTimeout"] !== undefined) {
        contents.GlobalTimeout = __strictParseInt32(output["GlobalTimeout"]);
    }
    if (output["DefaultResult"] !== undefined) {
        contents.DefaultResult = __expectString(output["DefaultResult"]);
    }
    return contents;
};
const de_LifecycleHooks = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LifecycleHook(entry, context);
    });
};
const de_LimitExceededFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_LoadBalancerNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_LoadBalancerState = (output, context) => {
    const contents = {};
    if (output["LoadBalancerName"] !== undefined) {
        contents.LoadBalancerName = __expectString(output["LoadBalancerName"]);
    }
    if (output["State"] !== undefined) {
        contents.State = __expectString(output["State"]);
    }
    return contents;
};
const de_LoadBalancerStates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancerState(entry, context);
    });
};
const de_LoadBalancerTargetGroupState = (output, context) => {
    const contents = {};
    if (output["LoadBalancerTargetGroupARN"] !== undefined) {
        contents.LoadBalancerTargetGroupARN = __expectString(output["LoadBalancerTargetGroupARN"]);
    }
    if (output["State"] !== undefined) {
        contents.State = __expectString(output["State"]);
    }
    return contents;
};
const de_LoadBalancerTargetGroupStates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancerTargetGroupState(entry, context);
    });
};
const de_LoadForecast = (output, context) => {
    const contents = {};
    if (output.Timestamps === "") {
        contents.Timestamps = [];
    }
    else if (output["Timestamps"] !== undefined && output["Timestamps"]["member"] !== undefined) {
        contents.Timestamps = de_PredictiveScalingForecastTimestamps(__getArrayIfSingleItem(output["Timestamps"]["member"]), context);
    }
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_PredictiveScalingForecastValues(__getArrayIfSingleItem(output["Values"]["member"]), context);
    }
    if (output["MetricSpecification"] !== undefined) {
        contents.MetricSpecification = de_PredictiveScalingMetricSpecification(output["MetricSpecification"], context);
    }
    return contents;
};
const de_LoadForecasts = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadForecast(entry, context);
    });
};
const de_LocalStorageTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MemoryGiBPerVCpuRequest = (output, context) => {
    const contents = {};
    if (output["Min"] !== undefined) {
        contents.Min = __strictParseFloat(output["Min"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = __strictParseFloat(output["Max"]);
    }
    return contents;
};
const de_MemoryMiBRequest = (output, context) => {
    const contents = {};
    if (output["Min"] !== undefined) {
        contents.Min = __strictParseInt32(output["Min"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = __strictParseInt32(output["Max"]);
    }
    return contents;
};
const de_Metric = (output, context) => {
    const contents = {};
    if (output["Namespace"] !== undefined) {
        contents.Namespace = __expectString(output["Namespace"]);
    }
    if (output["MetricName"] !== undefined) {
        contents.MetricName = __expectString(output["MetricName"]);
    }
    if (output.Dimensions === "") {
        contents.Dimensions = [];
    }
    else if (output["Dimensions"] !== undefined && output["Dimensions"]["member"] !== undefined) {
        contents.Dimensions = de_MetricDimensions(__getArrayIfSingleItem(output["Dimensions"]["member"]), context);
    }
    return contents;
};
const de_MetricCollectionType = (output, context) => {
    const contents = {};
    if (output["Metric"] !== undefined) {
        contents.Metric = __expectString(output["Metric"]);
    }
    return contents;
};
const de_MetricCollectionTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricCollectionType(entry, context);
    });
};
const de_MetricDataQueries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDataQuery(entry, context);
    });
};
const de_MetricDataQuery = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Expression"] !== undefined) {
        contents.Expression = __expectString(output["Expression"]);
    }
    if (output["MetricStat"] !== undefined) {
        contents.MetricStat = de_MetricStat(output["MetricStat"], context);
    }
    if (output["Label"] !== undefined) {
        contents.Label = __expectString(output["Label"]);
    }
    if (output["ReturnData"] !== undefined) {
        contents.ReturnData = __parseBoolean(output["ReturnData"]);
    }
    return contents;
};
const de_MetricDimension = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_MetricDimensions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDimension(entry, context);
    });
};
const de_MetricGranularityType = (output, context) => {
    const contents = {};
    if (output["Granularity"] !== undefined) {
        contents.Granularity = __expectString(output["Granularity"]);
    }
    return contents;
};
const de_MetricGranularityTypes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricGranularityType(entry, context);
    });
};
const de_MetricStat = (output, context) => {
    const contents = {};
    if (output["Metric"] !== undefined) {
        contents.Metric = de_Metric(output["Metric"], context);
    }
    if (output["Stat"] !== undefined) {
        contents.Stat = __expectString(output["Stat"]);
    }
    if (output["Unit"] !== undefined) {
        contents.Unit = __expectString(output["Unit"]);
    }
    return contents;
};
const de_MixedInstancesPolicy = (output, context) => {
    const contents = {};
    if (output["LaunchTemplate"] !== undefined) {
        contents.LaunchTemplate = de_LaunchTemplate(output["LaunchTemplate"], context);
    }
    if (output["InstancesDistribution"] !== undefined) {
        contents.InstancesDistribution = de_InstancesDistribution(output["InstancesDistribution"], context);
    }
    return contents;
};
const de_NetworkBandwidthGbpsRequest = (output, context) => {
    const contents = {};
    if (output["Min"] !== undefined) {
        contents.Min = __strictParseFloat(output["Min"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = __strictParseFloat(output["Max"]);
    }
    return contents;
};
const de_NetworkInterfaceCountRequest = (output, context) => {
    const contents = {};
    if (output["Min"] !== undefined) {
        contents.Min = __strictParseInt32(output["Min"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = __strictParseInt32(output["Max"]);
    }
    return contents;
};
const de_NotificationConfiguration = (output, context) => {
    const contents = {};
    if (output["AutoScalingGroupName"] !== undefined) {
        contents.AutoScalingGroupName = __expectString(output["AutoScalingGroupName"]);
    }
    if (output["TopicARN"] !== undefined) {
        contents.TopicARN = __expectString(output["TopicARN"]);
    }
    if (output["NotificationType"] !== undefined) {
        contents.NotificationType = __expectString(output["NotificationType"]);
    }
    return contents;
};
const de_NotificationConfigurations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NotificationConfiguration(entry, context);
    });
};
const de_Overrides = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LaunchTemplateOverrides(entry, context);
    });
};
const de_PoliciesType = (output, context) => {
    const contents = {};
    if (output.ScalingPolicies === "") {
        contents.ScalingPolicies = [];
    }
    else if (output["ScalingPolicies"] !== undefined && output["ScalingPolicies"]["member"] !== undefined) {
        contents.ScalingPolicies = de_ScalingPolicies(__getArrayIfSingleItem(output["ScalingPolicies"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_PolicyARNType = (output, context) => {
    const contents = {};
    if (output["PolicyARN"] !== undefined) {
        contents.PolicyARN = __expectString(output["PolicyARN"]);
    }
    if (output.Alarms === "") {
        contents.Alarms = [];
    }
    else if (output["Alarms"] !== undefined && output["Alarms"]["member"] !== undefined) {
        contents.Alarms = de_Alarms(__getArrayIfSingleItem(output["Alarms"]["member"]), context);
    }
    return contents;
};
const de_PredefinedMetricSpecification = (output, context) => {
    const contents = {};
    if (output["PredefinedMetricType"] !== undefined) {
        contents.PredefinedMetricType = __expectString(output["PredefinedMetricType"]);
    }
    if (output["ResourceLabel"] !== undefined) {
        contents.ResourceLabel = __expectString(output["ResourceLabel"]);
    }
    return contents;
};
const de_PredictiveScalingConfiguration = (output, context) => {
    const contents = {};
    if (output.MetricSpecifications === "") {
        contents.MetricSpecifications = [];
    }
    else if (output["MetricSpecifications"] !== undefined && output["MetricSpecifications"]["member"] !== undefined) {
        contents.MetricSpecifications = de_PredictiveScalingMetricSpecifications(__getArrayIfSingleItem(output["MetricSpecifications"]["member"]), context);
    }
    if (output["Mode"] !== undefined) {
        contents.Mode = __expectString(output["Mode"]);
    }
    if (output["SchedulingBufferTime"] !== undefined) {
        contents.SchedulingBufferTime = __strictParseInt32(output["SchedulingBufferTime"]);
    }
    if (output["MaxCapacityBreachBehavior"] !== undefined) {
        contents.MaxCapacityBreachBehavior = __expectString(output["MaxCapacityBreachBehavior"]);
    }
    if (output["MaxCapacityBuffer"] !== undefined) {
        contents.MaxCapacityBuffer = __strictParseInt32(output["MaxCapacityBuffer"]);
    }
    return contents;
};
const de_PredictiveScalingCustomizedCapacityMetric = (output, context) => {
    const contents = {};
    if (output.MetricDataQueries === "") {
        contents.MetricDataQueries = [];
    }
    else if (output["MetricDataQueries"] !== undefined && output["MetricDataQueries"]["member"] !== undefined) {
        contents.MetricDataQueries = de_MetricDataQueries(__getArrayIfSingleItem(output["MetricDataQueries"]["member"]), context);
    }
    return contents;
};
const de_PredictiveScalingCustomizedLoadMetric = (output, context) => {
    const contents = {};
    if (output.MetricDataQueries === "") {
        contents.MetricDataQueries = [];
    }
    else if (output["MetricDataQueries"] !== undefined && output["MetricDataQueries"]["member"] !== undefined) {
        contents.MetricDataQueries = de_MetricDataQueries(__getArrayIfSingleItem(output["MetricDataQueries"]["member"]), context);
    }
    return contents;
};
const de_PredictiveScalingCustomizedScalingMetric = (output, context) => {
    const contents = {};
    if (output.MetricDataQueries === "") {
        contents.MetricDataQueries = [];
    }
    else if (output["MetricDataQueries"] !== undefined && output["MetricDataQueries"]["member"] !== undefined) {
        contents.MetricDataQueries = de_MetricDataQueries(__getArrayIfSingleItem(output["MetricDataQueries"]["member"]), context);
    }
    return contents;
};
const de_PredictiveScalingForecastTimestamps = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectNonNull(__parseRfc3339DateTimeWithOffset(entry));
    });
};
const de_PredictiveScalingForecastValues = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseFloat(entry);
    });
};
const de_PredictiveScalingMetricSpecification = (output, context) => {
    const contents = {};
    if (output["TargetValue"] !== undefined) {
        contents.TargetValue = __strictParseFloat(output["TargetValue"]);
    }
    if (output["PredefinedMetricPairSpecification"] !== undefined) {
        contents.PredefinedMetricPairSpecification = de_PredictiveScalingPredefinedMetricPair(output["PredefinedMetricPairSpecification"], context);
    }
    if (output["PredefinedScalingMetricSpecification"] !== undefined) {
        contents.PredefinedScalingMetricSpecification = de_PredictiveScalingPredefinedScalingMetric(output["PredefinedScalingMetricSpecification"], context);
    }
    if (output["PredefinedLoadMetricSpecification"] !== undefined) {
        contents.PredefinedLoadMetricSpecification = de_PredictiveScalingPredefinedLoadMetric(output["PredefinedLoadMetricSpecification"], context);
    }
    if (output["CustomizedScalingMetricSpecification"] !== undefined) {
        contents.CustomizedScalingMetricSpecification = de_PredictiveScalingCustomizedScalingMetric(output["CustomizedScalingMetricSpecification"], context);
    }
    if (output["CustomizedLoadMetricSpecification"] !== undefined) {
        contents.CustomizedLoadMetricSpecification = de_PredictiveScalingCustomizedLoadMetric(output["CustomizedLoadMetricSpecification"], context);
    }
    if (output["CustomizedCapacityMetricSpecification"] !== undefined) {
        contents.CustomizedCapacityMetricSpecification = de_PredictiveScalingCustomizedCapacityMetric(output["CustomizedCapacityMetricSpecification"], context);
    }
    return contents;
};
const de_PredictiveScalingMetricSpecifications = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PredictiveScalingMetricSpecification(entry, context);
    });
};
const de_PredictiveScalingPredefinedLoadMetric = (output, context) => {
    const contents = {};
    if (output["PredefinedMetricType"] !== undefined) {
        contents.PredefinedMetricType = __expectString(output["PredefinedMetricType"]);
    }
    if (output["ResourceLabel"] !== undefined) {
        contents.ResourceLabel = __expectString(output["ResourceLabel"]);
    }
    return contents;
};
const de_PredictiveScalingPredefinedMetricPair = (output, context) => {
    const contents = {};
    if (output["PredefinedMetricType"] !== undefined) {
        contents.PredefinedMetricType = __expectString(output["PredefinedMetricType"]);
    }
    if (output["ResourceLabel"] !== undefined) {
        contents.ResourceLabel = __expectString(output["ResourceLabel"]);
    }
    return contents;
};
const de_PredictiveScalingPredefinedScalingMetric = (output, context) => {
    const contents = {};
    if (output["PredefinedMetricType"] !== undefined) {
        contents.PredefinedMetricType = __expectString(output["PredefinedMetricType"]);
    }
    if (output["ResourceLabel"] !== undefined) {
        contents.ResourceLabel = __expectString(output["ResourceLabel"]);
    }
    return contents;
};
const de_Processes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProcessType(entry, context);
    });
};
const de_ProcessesType = (output, context) => {
    const contents = {};
    if (output.Processes === "") {
        contents.Processes = [];
    }
    else if (output["Processes"] !== undefined && output["Processes"]["member"] !== undefined) {
        contents.Processes = de_Processes(__getArrayIfSingleItem(output["Processes"]["member"]), context);
    }
    return contents;
};
const de_ProcessType = (output, context) => {
    const contents = {};
    if (output["ProcessName"] !== undefined) {
        contents.ProcessName = __expectString(output["ProcessName"]);
    }
    return contents;
};
const de_PutLifecycleHookAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_PutWarmPoolAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_RecordLifecycleActionHeartbeatAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_RefreshPreferences = (output, context) => {
    const contents = {};
    if (output["MinHealthyPercentage"] !== undefined) {
        contents.MinHealthyPercentage = __strictParseInt32(output["MinHealthyPercentage"]);
    }
    if (output["InstanceWarmup"] !== undefined) {
        contents.InstanceWarmup = __strictParseInt32(output["InstanceWarmup"]);
    }
    if (output.CheckpointPercentages === "") {
        contents.CheckpointPercentages = [];
    }
    else if (output["CheckpointPercentages"] !== undefined && output["CheckpointPercentages"]["member"] !== undefined) {
        contents.CheckpointPercentages = de_CheckpointPercentages(__getArrayIfSingleItem(output["CheckpointPercentages"]["member"]), context);
    }
    if (output["CheckpointDelay"] !== undefined) {
        contents.CheckpointDelay = __strictParseInt32(output["CheckpointDelay"]);
    }
    if (output["SkipMatching"] !== undefined) {
        contents.SkipMatching = __parseBoolean(output["SkipMatching"]);
    }
    if (output["AutoRollback"] !== undefined) {
        contents.AutoRollback = __parseBoolean(output["AutoRollback"]);
    }
    if (output["ScaleInProtectedInstances"] !== undefined) {
        contents.ScaleInProtectedInstances = __expectString(output["ScaleInProtectedInstances"]);
    }
    if (output["StandbyInstances"] !== undefined) {
        contents.StandbyInstances = __expectString(output["StandbyInstances"]);
    }
    return contents;
};
const de_ResourceContentionFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ResourceInUseFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_RollbackDetails = (output, context) => {
    const contents = {};
    if (output["RollbackReason"] !== undefined) {
        contents.RollbackReason = __expectString(output["RollbackReason"]);
    }
    if (output["RollbackStartTime"] !== undefined) {
        contents.RollbackStartTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["RollbackStartTime"]));
    }
    if (output["PercentageCompleteOnRollback"] !== undefined) {
        contents.PercentageCompleteOnRollback = __strictParseInt32(output["PercentageCompleteOnRollback"]);
    }
    if (output["InstancesToUpdateOnRollback"] !== undefined) {
        contents.InstancesToUpdateOnRollback = __strictParseInt32(output["InstancesToUpdateOnRollback"]);
    }
    if (output["ProgressDetailsOnRollback"] !== undefined) {
        contents.ProgressDetailsOnRollback = de_InstanceRefreshProgressDetails(output["ProgressDetailsOnRollback"], context);
    }
    return contents;
};
const de_RollbackInstanceRefreshAnswer = (output, context) => {
    const contents = {};
    if (output["InstanceRefreshId"] !== undefined) {
        contents.InstanceRefreshId = __expectString(output["InstanceRefreshId"]);
    }
    return contents;
};
const de_ScalingActivityInProgressFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ScalingPolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ScalingPolicy(entry, context);
    });
};
const de_ScalingPolicy = (output, context) => {
    const contents = {};
    if (output["AutoScalingGroupName"] !== undefined) {
        contents.AutoScalingGroupName = __expectString(output["AutoScalingGroupName"]);
    }
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = __expectString(output["PolicyName"]);
    }
    if (output["PolicyARN"] !== undefined) {
        contents.PolicyARN = __expectString(output["PolicyARN"]);
    }
    if (output["PolicyType"] !== undefined) {
        contents.PolicyType = __expectString(output["PolicyType"]);
    }
    if (output["AdjustmentType"] !== undefined) {
        contents.AdjustmentType = __expectString(output["AdjustmentType"]);
    }
    if (output["MinAdjustmentStep"] !== undefined) {
        contents.MinAdjustmentStep = __strictParseInt32(output["MinAdjustmentStep"]);
    }
    if (output["MinAdjustmentMagnitude"] !== undefined) {
        contents.MinAdjustmentMagnitude = __strictParseInt32(output["MinAdjustmentMagnitude"]);
    }
    if (output["ScalingAdjustment"] !== undefined) {
        contents.ScalingAdjustment = __strictParseInt32(output["ScalingAdjustment"]);
    }
    if (output["Cooldown"] !== undefined) {
        contents.Cooldown = __strictParseInt32(output["Cooldown"]);
    }
    if (output.StepAdjustments === "") {
        contents.StepAdjustments = [];
    }
    else if (output["StepAdjustments"] !== undefined && output["StepAdjustments"]["member"] !== undefined) {
        contents.StepAdjustments = de_StepAdjustments(__getArrayIfSingleItem(output["StepAdjustments"]["member"]), context);
    }
    if (output["MetricAggregationType"] !== undefined) {
        contents.MetricAggregationType = __expectString(output["MetricAggregationType"]);
    }
    if (output["EstimatedInstanceWarmup"] !== undefined) {
        contents.EstimatedInstanceWarmup = __strictParseInt32(output["EstimatedInstanceWarmup"]);
    }
    if (output.Alarms === "") {
        contents.Alarms = [];
    }
    else if (output["Alarms"] !== undefined && output["Alarms"]["member"] !== undefined) {
        contents.Alarms = de_Alarms(__getArrayIfSingleItem(output["Alarms"]["member"]), context);
    }
    if (output["TargetTrackingConfiguration"] !== undefined) {
        contents.TargetTrackingConfiguration = de_TargetTrackingConfiguration(output["TargetTrackingConfiguration"], context);
    }
    if (output["Enabled"] !== undefined) {
        contents.Enabled = __parseBoolean(output["Enabled"]);
    }
    if (output["PredictiveScalingConfiguration"] !== undefined) {
        contents.PredictiveScalingConfiguration = de_PredictiveScalingConfiguration(output["PredictiveScalingConfiguration"], context);
    }
    return contents;
};
const de_ScheduledActionsType = (output, context) => {
    const contents = {};
    if (output.ScheduledUpdateGroupActions === "") {
        contents.ScheduledUpdateGroupActions = [];
    }
    else if (output["ScheduledUpdateGroupActions"] !== undefined &&
        output["ScheduledUpdateGroupActions"]["member"] !== undefined) {
        contents.ScheduledUpdateGroupActions = de_ScheduledUpdateGroupActions(__getArrayIfSingleItem(output["ScheduledUpdateGroupActions"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_ScheduledUpdateGroupAction = (output, context) => {
    const contents = {};
    if (output["AutoScalingGroupName"] !== undefined) {
        contents.AutoScalingGroupName = __expectString(output["AutoScalingGroupName"]);
    }
    if (output["ScheduledActionName"] !== undefined) {
        contents.ScheduledActionName = __expectString(output["ScheduledActionName"]);
    }
    if (output["ScheduledActionARN"] !== undefined) {
        contents.ScheduledActionARN = __expectString(output["ScheduledActionARN"]);
    }
    if (output["Time"] !== undefined) {
        contents.Time = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["Time"]));
    }
    if (output["StartTime"] !== undefined) {
        contents.StartTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["StartTime"]));
    }
    if (output["EndTime"] !== undefined) {
        contents.EndTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["EndTime"]));
    }
    if (output["Recurrence"] !== undefined) {
        contents.Recurrence = __expectString(output["Recurrence"]);
    }
    if (output["MinSize"] !== undefined) {
        contents.MinSize = __strictParseInt32(output["MinSize"]);
    }
    if (output["MaxSize"] !== undefined) {
        contents.MaxSize = __strictParseInt32(output["MaxSize"]);
    }
    if (output["DesiredCapacity"] !== undefined) {
        contents.DesiredCapacity = __strictParseInt32(output["DesiredCapacity"]);
    }
    if (output["TimeZone"] !== undefined) {
        contents.TimeZone = __expectString(output["TimeZone"]);
    }
    return contents;
};
const de_ScheduledUpdateGroupActions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ScheduledUpdateGroupAction(entry, context);
    });
};
const de_SecurityGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ServiceLinkedRoleFailure = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_SetInstanceProtectionAnswer = (output, context) => {
    const contents = {};
    return contents;
};
const de_StartInstanceRefreshAnswer = (output, context) => {
    const contents = {};
    if (output["InstanceRefreshId"] !== undefined) {
        contents.InstanceRefreshId = __expectString(output["InstanceRefreshId"]);
    }
    return contents;
};
const de_StepAdjustment = (output, context) => {
    const contents = {};
    if (output["MetricIntervalLowerBound"] !== undefined) {
        contents.MetricIntervalLowerBound = __strictParseFloat(output["MetricIntervalLowerBound"]);
    }
    if (output["MetricIntervalUpperBound"] !== undefined) {
        contents.MetricIntervalUpperBound = __strictParseFloat(output["MetricIntervalUpperBound"]);
    }
    if (output["ScalingAdjustment"] !== undefined) {
        contents.ScalingAdjustment = __strictParseInt32(output["ScalingAdjustment"]);
    }
    return contents;
};
const de_StepAdjustments = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StepAdjustment(entry, context);
    });
};
const de_SuspendedProcess = (output, context) => {
    const contents = {};
    if (output["ProcessName"] !== undefined) {
        contents.ProcessName = __expectString(output["ProcessName"]);
    }
    if (output["SuspensionReason"] !== undefined) {
        contents.SuspensionReason = __expectString(output["SuspensionReason"]);
    }
    return contents;
};
const de_SuspendedProcesses = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SuspendedProcess(entry, context);
    });
};
const de_TagDescription = (output, context) => {
    const contents = {};
    if (output["ResourceId"] !== undefined) {
        contents.ResourceId = __expectString(output["ResourceId"]);
    }
    if (output["ResourceType"] !== undefined) {
        contents.ResourceType = __expectString(output["ResourceType"]);
    }
    if (output["Key"] !== undefined) {
        contents.Key = __expectString(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    if (output["PropagateAtLaunch"] !== undefined) {
        contents.PropagateAtLaunch = __parseBoolean(output["PropagateAtLaunch"]);
    }
    return contents;
};
const de_TagDescriptionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TagDescription(entry, context);
    });
};
const de_TagsType = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_TagDescriptionList(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_TargetGroupARNs = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_TargetTrackingConfiguration = (output, context) => {
    const contents = {};
    if (output["PredefinedMetricSpecification"] !== undefined) {
        contents.PredefinedMetricSpecification = de_PredefinedMetricSpecification(output["PredefinedMetricSpecification"], context);
    }
    if (output["CustomizedMetricSpecification"] !== undefined) {
        contents.CustomizedMetricSpecification = de_CustomizedMetricSpecification(output["CustomizedMetricSpecification"], context);
    }
    if (output["TargetValue"] !== undefined) {
        contents.TargetValue = __strictParseFloat(output["TargetValue"]);
    }
    if (output["DisableScaleIn"] !== undefined) {
        contents.DisableScaleIn = __parseBoolean(output["DisableScaleIn"]);
    }
    return contents;
};
const de_TargetTrackingMetricDataQueries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetTrackingMetricDataQuery(entry, context);
    });
};
const de_TargetTrackingMetricDataQuery = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Expression"] !== undefined) {
        contents.Expression = __expectString(output["Expression"]);
    }
    if (output["MetricStat"] !== undefined) {
        contents.MetricStat = de_TargetTrackingMetricStat(output["MetricStat"], context);
    }
    if (output["Label"] !== undefined) {
        contents.Label = __expectString(output["Label"]);
    }
    if (output["ReturnData"] !== undefined) {
        contents.ReturnData = __parseBoolean(output["ReturnData"]);
    }
    return contents;
};
const de_TargetTrackingMetricStat = (output, context) => {
    const contents = {};
    if (output["Metric"] !== undefined) {
        contents.Metric = de_Metric(output["Metric"], context);
    }
    if (output["Stat"] !== undefined) {
        contents.Stat = __expectString(output["Stat"]);
    }
    if (output["Unit"] !== undefined) {
        contents.Unit = __expectString(output["Unit"]);
    }
    return contents;
};
const de_TerminationPolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_TotalLocalStorageGBRequest = (output, context) => {
    const contents = {};
    if (output["Min"] !== undefined) {
        contents.Min = __strictParseFloat(output["Min"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = __strictParseFloat(output["Max"]);
    }
    return contents;
};
const de_TrafficSourceIdentifier = (output, context) => {
    const contents = {};
    if (output["Identifier"] !== undefined) {
        contents.Identifier = __expectString(output["Identifier"]);
    }
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    return contents;
};
const de_TrafficSources = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficSourceIdentifier(entry, context);
    });
};
const de_TrafficSourceState = (output, context) => {
    const contents = {};
    if (output["TrafficSource"] !== undefined) {
        contents.TrafficSource = __expectString(output["TrafficSource"]);
    }
    if (output["State"] !== undefined) {
        contents.State = __expectString(output["State"]);
    }
    if (output["Identifier"] !== undefined) {
        contents.Identifier = __expectString(output["Identifier"]);
    }
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    return contents;
};
const de_TrafficSourceStates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrafficSourceState(entry, context);
    });
};
const de_VCpuCountRequest = (output, context) => {
    const contents = {};
    if (output["Min"] !== undefined) {
        contents.Min = __strictParseInt32(output["Min"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = __strictParseInt32(output["Max"]);
    }
    return contents;
};
const de_WarmPoolConfiguration = (output, context) => {
    const contents = {};
    if (output["MaxGroupPreparedCapacity"] !== undefined) {
        contents.MaxGroupPreparedCapacity = __strictParseInt32(output["MaxGroupPreparedCapacity"]);
    }
    if (output["MinSize"] !== undefined) {
        contents.MinSize = __strictParseInt32(output["MinSize"]);
    }
    if (output["PoolState"] !== undefined) {
        contents.PoolState = __expectString(output["PoolState"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["InstanceReusePolicy"] !== undefined) {
        contents.InstanceReusePolicy = de_InstanceReusePolicy(output["InstanceReusePolicy"], context);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
